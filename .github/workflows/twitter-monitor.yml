name: Twitter Discord Bot (デバッグ強化版)

on:
  schedule:
    # 5分ごとに実行
    - cron: '*/5 * * * *'
  workflow_dispatch:
    inputs:
      force_check:
        description: '強制実行（テスト用）'
        required: false
        default: 'false'
      debug_level:
        description: 'デバッグレベル (1-3)'
        required: false
        default: '2'

jobs:
  monitor-twitter:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    # 状態管理用キャッシュ
    - name: Cache bot state
      uses: actions/cache@v3
      with:
        path: |
          bot_state.json
          processed_tweets.json
        key: twitter-bot-state-${{ github.run_number }}
        restore-keys: |
          twitter-bot-state-
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install requests pytz
    
    # 環境変数の検証
    - name: Validate environment variables
      run: |
        echo "🔍 環境変数チェック開始..."
        if [ -z "$BEARER_TOKEN" ]; then echo "❌ BEARER_TOKEN が設定されていません"; exit 1; fi
        if [ -z "$DISCORD_WEBHOOK" ]; then echo "❌ DISCORD_WEBHOOK が設定されていません"; exit 1; fi
        if [ -z "$TARGET_USER" ]; then echo "❌ TARGET_USER が設定されていません"; exit 1; fi
        if [ -z "$KEYWORDS" ]; then echo "❌ KEYWORDS が設定されていません"; exit 1; fi
        echo "✅ 基本環境変数OK"
        echo "📊 TARGET_USER: $TARGET_USER"
        echo "📊 KEYWORDS: $KEYWORDS"
        echo "📊 WEBHOOK URL 長さ: ${#DISCORD_WEBHOOK}"
      env:
        BEARER_TOKEN: ${{ secrets.BEARER_TOKEN }}
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        TARGET_USER: ${{ secrets.TARGET_USER }}
        KEYWORDS: ${{ secrets.KEYWORDS }}
    
    # Discord Webhook テスト
    - name: Test Discord webhook
      run: |
        python << 'EOF'
        import requests
        import os
        import json
        from datetime import datetime
        
        webhook_url = os.environ.get('DISCORD_WEBHOOK')
        
        test_payload = {
            "content": "🧪 **Webhook接続テスト**",
            "embeds": [{
                "title": "✅ GitHub Actions → Discord 接続確認",
                "description": f"実行時刻: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}",
                "color": 0x00ff00,
                "footer": {"text": "Twitter Bot 接続テスト"}
            }]
        }
        
        try:
            print("🔄 Discord Webhook テスト実行中...")
            response = requests.post(webhook_url, json=test_payload, timeout=30)
            print(f"📡 レスポンス: {response.status_code}")
            print(f"📡 ヘッダー: {dict(response.headers)}")
            
            if response.status_code in [200, 204]:
                print("✅ Webhook テスト成功！")
            else:
                print(f"❌ Webhook エラー: {response.status_code}")
                print(f"📝 レスポンス内容: {response.text}")
        except Exception as e:
            print(f"❌ Webhook テスト失敗: {e}")
        EOF
      env:
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
    
    - name: Run Twitter monitor
      env:
        BEARER_TOKEN: ${{ secrets.BEARER_TOKEN }}
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        TARGET_USER: ${{ secrets.TARGET_USER }}
        KEYWORDS: ${{ secrets.KEYWORDS }}
        DEBUG_MODE: 'true'
        DEBUG_LEVEL: ${{ github.event.inputs.debug_level || '2' }}
        MAX_TWEETS_PER_RUN: ${{ secrets.MAX_TWEETS_PER_RUN || '10' }}
        NOTIFICATION_COOLDOWN: ${{ secrets.NOTIFICATION_COOLDOWN || '300' }}
      run: |
        python << 'EOF'
        import requests
        import os
        import json
        from datetime import datetime, timedelta, timezone
        import re
        import time
        import traceback
        import pytz
        
        class TwitterMonitorBot:
            def __init__(self):
                # 設定読み込み
                self.bearer_token = os.environ.get('BEARER_TOKEN')
                self.webhook_url = os.environ.get('DISCORD_WEBHOOK')
                self.target_user = os.environ.get('TARGET_USER')
                self.keywords = [k.strip() for k in os.environ.get('KEYWORDS', '').split(',') if k.strip()]
                self.debug_mode = os.environ.get('DEBUG_MODE', 'false').lower() == 'true'
                self.debug_level = int(os.environ.get('DEBUG_LEVEL', '2'))
                self.max_tweets_per_run = int(os.environ.get('MAX_TWEETS_PER_RUN', '10'))
                self.notification_cooldown = int(os.environ.get('NOTIFICATION_COOLDOWN', '300'))
                
                # 統計情報
                self.stats = {
                    'tweets_checked': 0,
                    'notifications_sent': 0,
                    'api_calls': 0,
                    'errors': 0,
                    'start_time': datetime.utcnow()
                }
                
                # Twitter API headers
                self.headers = {
                    'Authorization': f'Bearer {self.bearer_token}',
                    'User-Agent': 'TwitterBot/3.1'
                }
                
                # 日本時間設定
                self.jst = pytz.timezone('Asia/Tokyo')
                
                self.log(f"🤖 Twitter Monitor Bot v3.1 起動 (デバッグレベル: {self.debug_level})")
                self.log(f"🎯 監視対象: @{self.target_user}")
                self.log(f"🔑 キーワード: {', '.join(self.keywords)}")
                self.log(f"🔗 Webhook URL: {'設定済み' if self.webhook_url else '未設定'}")
                
                # 設定検証
                self.validate_config()
        
            def validate_config(self):
                """設定の検証"""
                issues = []
                if not self.bearer_token:
                    issues.append("BEARER_TOKEN未設定")
                if not self.webhook_url:
                    issues.append("DISCORD_WEBHOOK未設定")
                elif not self.webhook_url.startswith('https://discord.com/api/webhooks/'):
                    issues.append("DISCORD_WEBHOOK形式が不正")
                if not self.target_user:
                    issues.append("TARGET_USER未設定")
                if not self.keywords:
                    issues.append("KEYWORDS未設定")
                
                if issues:
                    self.log(f"❌ 設定問題: {', '.join(issues)}", "ERROR")
                    raise ValueError(f"設定問題: {', '.join(issues)}")
                else:
                    self.log("✅ 設定検証完了")
        
            def log(self, message, level="INFO"):
                """改善されたログ出力"""
                timestamp = datetime.now(self.jst).strftime('%Y-%m-%d %H:%M:%S JST')
                print(f"[{timestamp}] [{level}] {message}")
                
                # デバッグレベル3の場合は詳細ログもDiscordに送信
                if self.debug_level >= 3 and level in ["ERROR", "WARNING"] and hasattr(self, 'webhook_url'):
                    self.send_debug_log(message, level)
        
            def send_debug_log(self, message, level):
                """デバッグログをDiscordに送信"""
                try:
                    color_map = {"ERROR": 0xff0000, "WARNING": 0xff9900, "INFO": 0x0099ff}
                    
                    embed = {
                        "title": f"🐛 デバッグログ [{level}]",
                        "description": f"```{message[:1500]}```",
                        "color": color_map.get(level, 0x808080),
                        "timestamp": datetime.utcnow().isoformat()
                    }
                    
                    payload = {"embeds": [embed]}
                    requests.post(self.webhook_url, json=payload, timeout=10)
                except:
                    pass  # デバッグログの送信エラーは無視
        
            def load_state(self):
                """状態ファイルの読み込み"""
                try:
                    with open('bot_state.json', 'r', encoding='utf-8') as f:
                        state = json.load(f)
                        self.log(f"📂 状態ファイル読み込み成功: last_tweet_id={state.get('last_tweet_id', 'None')}")
                        return state
                except FileNotFoundError:
                    self.log("📂 状態ファイルが見つかりません。新規作成します。")
                    return {
                        'last_tweet_id': None,
                        'last_run_time': None,
                        'total_notifications': 0,
                        'total_tweets_processed': 0
                    }
                except Exception as e:
                    self.log(f"❌ 状態ファイル読み込みエラー: {e}", "ERROR")
                    return {}
        
            def save_state(self, state):
                """状態ファイルの保存"""
                try:
                    state['last_run_time'] = datetime.utcnow().isoformat()
                    with open('bot_state.json', 'w', encoding='utf-8') as f:
                        json.dump(state, f, ensure_ascii=False, indent=2)
                    self.log("💾 状態ファイル保存完了")
                except Exception as e:
                    self.log(f"❌ 状態ファイル保存エラー: {e}", "ERROR")
        
            def make_api_request(self, url, params=None, max_retries=3):
                """API リクエスト（デバッグ強化版）"""
                self.stats['api_calls'] += 1
                
                if self.debug_level >= 2:
                    self.log(f"🌐 API Request: {url}")
                    if params:
                        self.log(f"📝 Parameters: {params}")
                
                for attempt in range(max_retries):
                    try:
                        response = requests.get(url, headers=self.headers, params=params, timeout=30)
                        
                        if self.debug_level >= 3:
                            self.log(f"📡 Response: {response.status_code} - {len(response.text)}文字")
                        
                        if response.status_code == 200:
                            return response
                        elif response.status_code == 429:
                            reset_time = response.headers.get('x-rate-limit-reset')
                            self.log(f"⚠️ API制限 (リセット時刻: {reset_time})", "WARNING")
                            if attempt < max_retries - 1:
                                wait_time = min((2 ** attempt) * 60, 900)  # 最大15分
                                self.log(f"⏳ {wait_time}秒待機中...")
                                time.sleep(wait_time)
                                continue
                        elif response.status_code == 401:
                            self.log("❌ 認証エラー: Bearer Tokenを確認してください", "ERROR")
                            return None
                        else:
                            self.log(f"❌ API エラー: {response.status_code} - {response.text[:200]}", "ERROR")
                            if attempt < max_retries - 1:
                                time.sleep(5)
                                continue
                            
                    except Exception as e:
                        self.log(f"📡 リクエストエラー (試行 {attempt + 1}): {e}", "WARNING")
                        if attempt < max_retries - 1:
                            time.sleep(5)
                            continue
                
                self.stats['errors'] += 1
                return None
        
            def get_user_id(self):
                """ユーザーIDを取得"""
                user_url = f'https://api.twitter.com/2/users/by/username/{self.target_user}'
                response = self.make_api_request(user_url)
                
                if not response:
                    return None
                
                try:
                    user_data = response.json()
                    if 'data' not in user_data:
                        self.log(f"❌ ユーザー '{self.target_user}' が見つかりません", "ERROR")
                        if 'errors' in user_data:
                            self.log(f"📝 APIエラー詳細: {user_data['errors']}", "ERROR")
                        return None
                    
                    user_id = user_data['data']['id']
                    self.log(f"✅ ユーザーID取得: {user_id}")
                    return user_id
                    
                except Exception as e:
                    self.log(f"❌ ユーザーデータ解析エラー: {e}", "ERROR")
                    return None
        
            def get_recent_tweets(self, user_id, since_id=None):
                """最新ツイートを取得"""
                tweets_url = f'https://api.twitter.com/2/users/{user_id}/tweets'
                
                params = {
                    'max_results': min(self.max_tweets_per_run, 100),
                    'tweet.fields': 'created_at,public_metrics,context_annotations,lang',
                    'exclude': 'retweets,replies'
                }
                
                if since_id:
                    params['since_id'] = since_id
                    self.log(f"📊 since_id指定: {since_id}")
                else:
                    # 過去15分のツイートを取得
                    end_time = datetime.utcnow()
                    start_time = end_time - timedelta(minutes=15)
                    params['start_time'] = start_time.strftime('%Y-%m-%dT%H:%M:%SZ')
                    params['end_time'] = end_time.strftime('%Y-%m-%dT%H:%M:%SZ')
                    self.log(f"🕐 時間範囲: {start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')} UTC")
                
                response = self.make_api_request(tweets_url, params)
                
                if not response:
                    return None
                
                try:
                    tweets_data = response.json()
                    
                    if self.debug_level >= 2:
                        self.log(f"📊 APIレスポンス keys: {list(tweets_data.keys())}")
                    
                    if 'data' not in tweets_data:
                        if 'errors' in tweets_data:
                            self.log(f"❌ Twitter API エラー: {tweets_data['errors']}", "ERROR")
                        else:
                            self.log("ℹ️ 新しいツイートはありません")
                        return []
                    
                    tweets = tweets_data['data']
                    self.log(f"📝 {len(tweets)}件のツイートを取得")
                    self.stats['tweets_checked'] += len(tweets)
                    
                    if self.debug_level >= 2:
                        for i, tweet in enumerate(tweets[:3]):  # 最初の3件をサンプル表示
                            self.log(f"📄 Tweet {i+1}: {tweet['text'][:50]}...")
                    
                    return tweets
                    
                except Exception as e:
                    self.log(f"❌ ツイートデータ解析エラー: {e}", "ERROR")
                    return None
        
            def check_keywords(self, text, keywords):
                """キーワードチェック"""
                matched_keywords = []
                text_lower = text.lower()
                
                for keyword in keywords:
                    if keyword.lower() in text_lower:
                        matched_keywords.append(keyword)
                        if self.debug_level >= 2:
                            self.log(f"🎯 キーワードマッチ: '{keyword}' in '{text[:30]}...'")
                
                return matched_keywords
        
            def test_discord_webhook(self):
                """Discord Webhook のテスト"""
                test_payload = {
                    "content": "🧪 **Bot動作テスト**",
                    "embeds": [{
                        "title": "✅ Twitter監視Bot テスト通知",
                        "description": f"実行時刻: {datetime.now(self.jst).strftime('%Y-%m-%d %H:%M:%S JST')}",
                        "color": 0x00ff00,
                        "fields": [
                            {"name": "監視対象", "value": f"@{self.target_user}", "inline": True},
                            {"name": "キーワード", "value": ", ".join(self.keywords), "inline": True}
                        ]
                    }]
                }
                
                try:
                    response = requests.post(self.webhook_url, json=test_payload, timeout=30)
                    if response.status_code in [200, 204]:
                        self.log("✅ Discord Webhook テスト成功")
                        return True
                    else:
                        self.log(f"❌ Discord Webhook テストエラー: {response.status_code}", "ERROR")
                        return False
                except Exception as e:
                    self.log(f"❌ Discord Webhook テスト失敗: {e}", "ERROR")
                    return False
        
            def send_discord_notification(self, tweet_text, matched_keywords, tweet_data):
                """Discord通知送信（デバッグ強化版）"""
                try:
                    tweet_id = tweet_data['id']
                    created_at = tweet_data['created_at']
                    
                    # UTC -> JST変換
                    utc_time = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                    jst_time = utc_time.astimezone(self.jst)
                    
                    # テキスト長制限
                    display_text = tweet_text if len(tweet_text) <= 300 else tweet_text[:300] + "..."
                    
                    embed = {
                        "title": f"🚨 キーワード検出: {', '.join(matched_keywords)}",
                        "description": display_text,
                        "color": 0x1DA1F2,
                        "fields": [
                            {
                                "name": "👤 投稿者",
                                "value": f"[@{self.target_user}](https://twitter.com/{self.target_user})",
                                "inline": True
                            },
                            {
                                "name": "🕐 投稿時刻",
                                "value": jst_time.strftime("%m/%d %H:%M JST"),
                                "inline": True
                            },
                            {
                                "name": "🔗 リンク",
                                "value": f"[ツイートを見る](https://twitter.com/{self.target_user}/status/{tweet_id})",
                                "inline": False
                            }
                        ],
                        "footer": {
                            "text": f"Twitter監視Bot v3.1 | Debug Level: {self.debug_level}",
                        },
                        "timestamp": created_at
                    }
                    
                    payload = {
                        "embeds": [embed],
                        "username": "Twitter監視Bot",
                        "avatar_url": "https://abs.twimg.com/icons/apple-touch-icon-192x192.png"
                    }
                    
                    if self.debug_level >= 2:
                        self.log(f"📤 Discord通知送信準備: {len(json.dumps(payload))}文字")
                    
                    # Discord API にリトライ付きで送信
                    for attempt in range(3):
                        try:
                            response = requests.post(self.webhook_url, json=payload, timeout=30)
                            
                            if self.debug_level >= 2:
                                self.log(f"📡 Discord Response: {response.status_code}")
                            
                            if response.status_code in [200, 204]:
                                self.log(f"✅ Discord通知送信成功 (試行: {attempt + 1})")
                                self.stats['notifications_sent'] += 1
                                return True
                            elif response.status_code == 429:
                                wait_time = 5 * (attempt + 1)
                                self.log(f"⚠️ Discord API制限 - {wait_time}秒待機", "WARNING")
                                time.sleep(wait_time)
                                continue
                            else:
                                self.log(f"❌ Discord通知エラー: {response.status_code} - {response.text[:200]}", "ERROR")
                                
                        except Exception as e:
                            self.log(f"❌ Discord通知送信エラー (試行 {attempt + 1}): {e}", "ERROR")
                            if attempt < 2:
                                time.sleep(5)
                                continue
                    
                    self.stats['errors'] += 1
                    return False
                    
                except Exception as e:
                    self.log(f"❌ 通知処理中の予期しないエラー: {e}", "ERROR")
                    if self.debug_level >= 3:
                        traceback.print_exc()
                    return False
        
            def send_summary_notification(self):
                """実行結果サマリーをDiscordに送信"""
                runtime = datetime.utcnow() - self.stats['start_time']
                
                status_color = 0x00ff00 if self.stats['errors'] == 0 else (0xff9900 if self.stats['errors'] < 3 else 0xff0000)
                status_text = "正常" if self.stats['errors'] == 0 else f"警告({self.stats['errors']}エラー)"
                
                embed = {
                    "title": f"📊 実行結果サマリー - {status_text}",
                    "color": status_color,
                    "fields": [
                        {"name": "🔍 チェックしたツイート数", "value": str(self.stats['tweets_checked']), "inline": True},
                        {"name": "🔔 送信した通知数", "value": str(self.stats['notifications_sent']), "inline": True},
                        {"name": "🌐 API呼び出し回数", "value": str(self.stats['api_calls']), "inline": True},
                        {"name": "❌ エラー回数", "value": str(self.stats['errors']), "inline": True},
                        {"name": "⏱️ 実行時間", "value": f"{runtime.total_seconds():.1f}秒", "inline": True},
                        {"name": "🕐 実行時刻", "value": datetime.now(self.jst).strftime("%m/%d %H:%M JST"), "inline": True}
                    ],
                    "footer": {"text": f"デバッグレベル {self.debug_level} | v3.1"},
                    "timestamp": datetime.utcnow().isoformat()
                }
                
                payload = {"embeds": [embed]}
                
                try:
                    response = requests.post(self.webhook_url, json=payload, timeout=10)
                    if response.status_code not in [200, 204]:
                        self.log(f"⚠️ サマリー送信エラー: {response.status_code}", "WARNING")
                except Exception as e:
                    self.log(f"⚠️ サマリー送信失敗: {e}", "WARNING")
        
            def run(self):
                """メイン処理"""
                try:
                    self.log("🚀 メイン処理開始")
                    
                    # Discord Webhook テスト（デバッグレベル2以上の場合）
                    if self.debug_level >= 2:
                        if not self.test_discord_webhook():
                            self.log("❌ Discord Webhook テストに失敗しました", "ERROR")
                            return
                    
                    # 状態読み込み
                    state = self.load_state()
                    
                    # ユーザーID取得
                    user_id = self.get_user_id()
                    if not user_id:
                        self.log("❌ ユーザーID取得失敗", "ERROR")
                        return
                    
                    # ツイート取得
                    tweets = self.get_recent_tweets(user_id, state.get('last_tweet_id'))
                    if tweets is None:
                        self.log("❌ ツイート取得失敗", "ERROR")
                        return
                    
                    if not tweets:
                        self.log("✅ 新しいツイートはありませんでした")
                        if self.debug_level >= 1:
                            self.send_summary_notification()
                        return
                    
                    # ツイート処理
                    tweets.sort(key=lambda x: x['created_at'])  # 古い順
                    notifications_sent = 0
                    new_last_tweet_id = state.get('last_tweet_id')
                    
                    for tweet in tweets:
                        tweet_id = tweet['id']
                        tweet_text = tweet['text']
                        
                        if self.debug_level >= 2:
                            self.log(f"🔍 ツイート分析: {tweet_id}")
                        
                        # キーワードチェック
                        matched_keywords = self.check_keywords(tweet_text, self.keywords)
                        
                        if matched_keywords:
                            self.log(f"🎯 キーワード検出: {matched_keywords}")
                            self.log(f"📝 ツイート内容: {tweet_text[:100]}...")
                            
                            # 通知送信
                            success = self.send_discord_notification(tweet_text, matched_keywords, tweet)
                            
                            if success:
                                notifications_sent += 1
                                self.log(f"🎉 通知送信成功: {matched_keywords}")
                            else:
                                self.log(f"❌ 通知送信失敗: {tweet_id}", "ERROR")
                        
                        new_last_tweet_id = tweet_id
                    
                    # 状態保存
                    state['last_tweet_id'] = new_last_tweet_id
                    state['total_notifications'] = state.get('total_notifications', 0) + notifications_sent
                    state['total_tweets_processed'] = state.get('total_tweets_processed', 0) + len(tweets)
                    self.save_state(state)
                    
                    # 結果出力
                    self.log(f"🎯 処理完了: {len(tweets)}件のツイートを確認, {notifications_sent}件の通知を送信")
                    
                    # サマリー送信
                    if self.debug_level >= 1 or notifications_sent > 0:
                        self.send_summary_notification()
                    
                except Exception as e:
                    self.log(f"❌ 予期しないエラー: {e}", "ERROR")
                    if self.debug_level >= 2:
                        traceback.print_exc()
                    
                    # エラー通知
                    try:
                        error_embed = {
                            "title": "🚨 Twitter Bot 重大エラー",
                            "description": f"```{str(e)[:1500]}```",
                            "color": 0xff0000,
                            "timestamp": datetime.utcnow().isoformat()
                        }
                        requests.post(self.webhook_url, json={"embeds": [error_embed]}, timeout=10)
                    except:
                        pass
        
        # メイン実行
        if __name__ == "__main__":
            bot = TwitterMonitorBot()
            bot.run()
        EOF
        # 現在のYAMLファイルに以下のステップを追加してください：

# 既存の "Install dependencies" ステップの後に追加：
    - name: Test Discord webhook connection
      run: |
        python << 'EOF'
        import requests
        import os
        from datetime import datetime
        
        webhook_url = os.environ.get('DISCORD_WEBHOOK')
        
        # 基本的な接続テスト
        test_payload = {
            "content": "🧪 **接続テスト**",
            "embeds": [{
                "title": "✅ GitHub Actions → Discord 接続確認",
                "description": f"実行時刻: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}",
                "color": 0x00ff00
            }]
        }
        
        try:
            print("🔄 Discord Webhook テスト実行中...")
            response = requests.post(webhook_url, json=test_payload, timeout=30)
            print(f"📡 ステータス: {response.status_code}")
            print(f"📡 レスポンス: {response.text}")
            
            if response.status_code in [200, 204]:
                print("✅ Webhook 接続成功！")
            else:
                print(f"❌ Webhook 接続失敗: {response.status_code}")
                print("🔍 Discord Webhook URLを確認してください")
        except Exception as e:
            print(f"❌ 接続エラー: {e}")
            print("🔍 ネットワークまたはURL設定を確認してください")
        EOF
      env:
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}

# 既存の "Run Twitter monitor" ステップの env セクションに追加：
        DEBUG_MODE: 'true'  # この行を追加
        
# そして、Pythonコードの send_discord_notification 関数を以下に置き換え：
