name: Twitter Discord Bot (デバッグ機能付き)

on:
  schedule:
    # 5分ごとに実行（API制限を考慮して最適化）
    - cron: '*/5 * * * *'
  workflow_dispatch:
    inputs:
      force_check:
        description: '強制実行（テスト用）'
        required: false
        default: 'false'

jobs:
  monitor-twitter:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    # 状態管理用キャッシュ
    - name: Cache bot state
      uses: actions/cache@v3
      with:
        path: |
          bot_state.json
          processed_tweets.json
        key: twitter-bot-state-${{ github.run_number }}
        restore-keys: |
          twitter-bot-state-
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install requests pytz
    
    # Discord Webhook 接続テスト（新規追加）
    - name: Test Discord webhook connection
      run: |
        python << 'EOF'
        import requests
        import os
        from datetime import datetime
        
        webhook_url = os.environ.get('DISCORD_WEBHOOK')
        
        print("=" * 50)
        print("🔍 Discord Webhook 接続テスト開始")
        print("=" * 50)
        print(f"📊 Webhook URL設定: {'✅ あり' if webhook_url else '❌ なし'}")
        if webhook_url:
            print(f"📊 URL長さ: {len(webhook_url)} 文字")
            print(f"📊 URL形式: {'✅ 正常' if webhook_url.startswith('https://discord.com/api/webhooks/') else '❌ 異常'}")
        
        if not webhook_url:
            print("❌ DISCORD_WEBHOOK が設定されていません")
            exit(1)
        
        # テスト通知送信
        test_payload = {
            "content": "🧪 **GitHub Actions接続テスト**",
            "embeds": [{
                "title": "✅ Discord Webhook 接続確認",
                "description": f"実行時刻: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}",
                "color": 0x00ff00,
                "fields": [
                    {"name": "ステータス", "value": "接続テスト実行中", "inline": True},
                    {"name": "実行元", "value": "GitHub Actions", "inline": True}
                ]
            }]
        }
        
        try:
            print("🔄 テスト通知送信中...")
            response = requests.post(webhook_url, json=test_payload, timeout=30)
            
            print(f"📡 HTTPステータス: {response.status_code}")
            print(f"📡 レスポンス内容: {response.text}")
            
            if response.status_code in [200, 204]:
                print("✅ Discord Webhook 接続成功！")
                print("🎉 Discordにテスト通知が送信されました")
            else:
                print(f"❌ Discord Webhook 接続失敗")
                if response.status_code == 404:
                    print("💡 Webhook URLが間違っているか、削除されています")
                elif response.status_code == 401:
                    print("💡 Webhook URLのトークン部分が間違っています")
                elif response.status_code == 429:
                    print("💡 Discord API制限に達しています")
                else:
                    print(f"💡 不明なエラー: {response.text}")
                    
        except requests.exceptions.Timeout:
            print("❌ タイムアウト: Discordサーバーへの接続が遅すぎます")
        except requests.exceptions.ConnectionError:
            print("❌ 接続エラー: インターネット接続またはDiscord側の問題")
        except Exception as e:
            print(f"❌ 予期しないエラー: {e}")
            import traceback
            traceback.print_exc()
        
        print("=" * 50)
        EOF
      env:
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}

    - name: Run Twitter monitor
      env:
        BEARER_TOKEN: ${{ secrets.BEARER_TOKEN }}
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        TARGET_USER: ${{ secrets.TARGET_USER }}
        KEYWORDS: ${{ secrets.KEYWORDS }}
        # デバッグモード有効化（新規追加）
        DEBUG_MODE: 'true'
        MAX_TWEETS_PER_RUN: ${{ secrets.MAX_TWEETS_PER_RUN || '10' }}
        NOTIFICATION_COOLDOWN: ${{ secrets.NOTIFICATION_COOLDOWN || '300' }}
      run: |
        python << 'EOF'
        import requests
        import os
        import json
        from datetime import datetime, timedelta, timezone
        import re
        import time
        import traceback
        import pytz
        
        class TwitterMonitorBot:
            def __init__(self):
                # 設定読み込み
                self.bearer_token = os.environ.get('BEARER_TOKEN')
                self.webhook_url = os.environ.get('DISCORD_WEBHOOK')
                self.target_user = os.environ.get('TARGET_USER')
                self.keywords = [k.strip() for k in os.environ.get('KEYWORDS', '').split(',') if k.strip()]
                self.debug_mode = os.environ.get('DEBUG_MODE', 'false').lower() == 'true'
                self.max_tweets_per_run = int(os.environ.get('MAX_TWEETS_PER_RUN', '10'))
                self.notification_cooldown = int(os.environ.get('NOTIFICATION_COOLDOWN', '300'))
                
                # 統計情報
                self.stats = {
                    'tweets_checked': 0,
                    'notifications_sent': 0,
                    'api_calls': 0,
                    'errors': 0,
                    'start_time': datetime.utcnow()
                }
                
                # Twitter API headers
                self.headers = {
                    'Authorization': f'Bearer {self.bearer_token}',
                    'User-Agent': 'TwitterBot/3.0'
                }
                
                # 日本時間設定
                self.jst = pytz.timezone('Asia/Tokyo')
                
                self.log(f"🤖 Twitter Monitor Bot v3.0 起動")
                self.log(f"🎯 監視対象: @{self.target_user}")
                self.log(f"🔑 キーワード: {', '.join(self.keywords)}")
                self.log(f"🐛 デバッグモード: {'ON' if self.debug_mode else 'OFF'}")
                
                # デバッグモード時は詳細ログ
                if self.debug_mode:
                    self.log(f"🔗 Webhook URL: {'設定済み' if self.webhook_url else '未設定'}")
                    self.log(f"🔑 Bearer Token: {'設定済み' if self.bearer_token else '未設定'}")
        
            def log(self, message, level="INFO"):
                """改善されたログ出力"""
                timestamp = datetime.now(self.jst).strftime('%Y-%m-%d %H:%M:%S JST')
                print(f"[{timestamp}] [{level}] {message}")
        
            def load_state(self):
                """状態ファイルの読み込み（永続化対応）"""
                try:
                    with open('bot_state.json', 'r', encoding='utf-8') as f:
                        state = json.load(f)
                        self.log(f"📂 状態ファイル読み込み成功: last_tweet_id={state.get('last_tweet_id', 'None')}")
                        return state
                except FileNotFoundError:
                    self.log("📂 状態ファイルが見つかりません。新規作成します。")
                    return {
                        'last_tweet_id': None,
                        'last_run_time': None,
                        'total_notifications': 0,
                        'total_tweets_processed': 0
                    }
                except json.JSONDecodeError as e:
                    self.log(f"❌ 状態ファイル読み込みエラー: {e}", "ERROR")
                    return {}
        
            def save_state(self, state):
                """状態ファイルの保存"""
                try:
                    state['last_run_time'] = datetime.utcnow().isoformat()
                    with open('bot_state.json', 'w', encoding='utf-8') as f:
                        json.dump(state, f, ensure_ascii=False, indent=2)
                    self.log("💾 状態ファイル保存完了")
                except Exception as e:
                    self.log(f"❌ 状態ファイル保存エラー: {e}", "ERROR")
        
            def load_processed_tweets(self):
                """処理済みツイートリストの読み込み"""
                try:
                    with open('processed_tweets.json', 'r', encoding='utf-8') as f:
                        data = json.load(f)
                        # 24時間以上古い記録は削除
                        cutoff_time = datetime.utcnow() - timedelta(hours=24)
                        filtered_data = {
                            tweet_id: timestamp for tweet_id, timestamp in data.items()
                            if datetime.fromisoformat(timestamp.replace('Z', '+00:00')) > cutoff_time
                        }
                        self.log(f"🧹 処理済みツイート: {len(data)} → {len(filtered_data)} (24時間でクリーンアップ)")
                        return filtered_data
                except FileNotFoundError:
                    self.log("📂 処理済みツイートファイルを新規作成")
                    return {}
                except Exception as e:
                    self.log(f"❌ 処理済みツイート読み込みエラー: {e}", "ERROR")
                    return {}
        
            def save_processed_tweets(self, processed_tweets):
                """処理済みツイートリストの保存"""
                try:
                    with open('processed_tweets.json', 'w', encoding='utf-8') as f:
                        json.dump(processed_tweets, f, ensure_ascii=False, indent=2)
                except Exception as e:
                    self.log(f"❌ 処理済みツイート保存エラー: {e}", "ERROR")
        
            def make_api_request(self, url, params=None, max_retries=3):
                """API リクエスト（リトライ機能付き）"""
                self.stats['api_calls'] += 1
                
                for attempt in range(max_retries):
                    try:
                        if self.debug_mode:
                            self.log(f"🌐 API Request (試行 {attempt + 1}): {url}")
                            if params:
                                self.log(f"📝 Parameters: {params}")
                        
                        response = requests.get(url, headers=self.headers, params=params, timeout=30)
                        
                        if self.debug_mode:
                            self.log(f"📡 API Response: {response.status_code}")
                        
                        if response.status_code == 200:
                            return response
                        elif response.status_code == 429:
                            self.log(f"⚠️ API制限に達しました (試行 {attempt + 1})", "WARNING")
                            if attempt < max_retries - 1:
                                wait_time = (2 ** attempt) * 60  # 指数バックオフ（分）
                                self.log(f"⏳ {wait_time}秒待機中...")
                                time.sleep(wait_time)
                                continue
                            else:
                                self.log("❌ API制限により処理を中断", "ERROR")
                                return None
                        elif response.status_code == 401:
                            self.log("❌ 認証エラー: Bearer Tokenを確認してください", "ERROR")
                            return None
                        else:
                            self.log(f"❌ API エラー: {response.status_code} - {response.text[:200]}", "ERROR")
                            if attempt < max_retries - 1:
                                time.sleep(5)
                                continue
                            return None
                            
                    except requests.exceptions.Timeout:
                        self.log(f"⏱️ タイムアウト (試行 {attempt + 1})", "WARNING")
                        if attempt < max_retries - 1:
                            time.sleep(10)
                            continue
                    except requests.exceptions.RequestException as e:
                        self.log(f"📡 リクエストエラー (試行 {attempt + 1}): {e}", "WARNING")
                        if attempt < max_retries - 1:
                            time.sleep(5)
                            continue
                
                self.stats['errors'] += 1
                return None
        
            def get_user_id(self):
                """ユーザーIDを取得"""
                user_url = f'https://api.twitter.com/2/users/by/username/{self.target_user}'
                response = self.make_api_request(user_url)
                
                if not response:
                    return None
                
                try:
                    user_data = response.json()
                    if self.debug_mode:
                        self.log(f"👤 User API Response: {list(user_data.keys())}")
                    
                    if 'data' not in user_data:
                        self.log(f"❌ ユーザー '{self.target_user}' が見つかりません", "ERROR")
                        if 'errors' in user_data:
                            self.log(f"📝 APIエラー詳細: {user_data['errors']}", "ERROR")
                        return None
                    
                    user_id = user_data['data']['id']
                    self.log(f"✅ ユーザーID取得: {user_id}")
                    return user_id
                except json.JSONDecodeError as e:
                    self.log(f"❌ ユーザーデータ解析エラー: {e}", "ERROR")
                    return None
        
            def get_recent_tweets(self, user_id, since_id=None):
                """最新ツイートを取得（改善版）"""
                tweets_url = f'https://api.twitter.com/2/users/{user_id}/tweets'
                
                params = {
                    'max_results': min(self.max_tweets_per_run, 100),
                    'tweet.fields': 'created_at,public_metrics,context_annotations,lang',
                    'exclude': 'retweets,replies'
                }
                
                # 前回処理したツイートIDがある場合は、それ以降のみ取得
                if since_id:
                    params['since_id'] = since_id
                    self.log(f"📊 since_id指定: {since_id}")
                else:
                    # since_idがない場合は過去15分のツイートのみ
                    end_time = datetime.utcnow()
                    start_time = end_time - timedelta(minutes=15)
                    params['start_time'] = start_time.strftime('%Y-%m-%dT%H:%M:%SZ')
                    params['end_time'] = end_time.strftime('%Y-%m-%dT%H:%M:%SZ')
                    if self.debug_mode:
                        self.log(f"🕐 時間範囲: {start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')} UTC")
                
                response = self.make_api_request(tweets_url, params)
                
                if not response:
                    return None
                
                try:
                    tweets_data = response.json()
                    
                    if self.debug_mode:
                        self.log(f"📊 Tweets API Response keys: {list(tweets_data.keys())}")
                    
                    if 'data' not in tweets_data or not tweets_data['data']:
                        if 'errors' in tweets_data:
                            self.log(f"❌ Twitter API エラー: {tweets_data['errors']}", "ERROR")
                        else:
                            self.log("ℹ️ 新しいツイートはありません")
                        return []
                    
                    tweets = tweets_data['data']
                    self.log(f"📝 {len(tweets)}件のツイートを取得")
                    self.stats['tweets_checked'] += len(tweets)
                    
                    # デバッグモード時はツイート内容をサンプル表示
                    if self.debug_mode:
                        for i, tweet in enumerate(tweets[:2]):  # 最初の2件
                            self.log(f"📄 Tweet {i+1} (ID: {tweet['id']}): {tweet['text'][:50]}...")
                    
                    return tweets
                except json.JSONDecodeError as e:
                    self.log(f"❌ ツイートデータ解析エラー: {e}", "ERROR")
                    return None
        
            def check_keywords(self, text, keywords):
                """キーワードチェック（改善版）"""
                matched_keywords = []
                text_lower = text.lower()
                
                for keyword in keywords:
                    # 完全一致、部分一致、正規表現対応
                    if re.search(re.escape(keyword.lower()), text_lower):
                        matched_keywords.append(keyword)
                        if self.debug_mode:
                            self.log(f"🎯 キーワードマッチ: '{keyword}' in '{text[:30]}...'")
                
                return matched_keywords
        
            def send_discord_notification(self, tweet_text, matched_keywords, tweet_data):
                """Discord通知送信（エラー処理強化版）"""
                try:
                    tweet_id = tweet_data['id']
                    created_at = tweet_data['created_at']
                    
                    if self.debug_mode:
                        self.log(f"📤 通知準備中: Tweet ID {tweet_id}")
                    
                    # UTC -> JST変換
                    utc_time = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                    jst_time = utc_time.astimezone(self.jst)
                    
                    # テキスト長制限
                    display_text = tweet_text if len(tweet_text) <= 300 else tweet_text[:300] + "..."
                    
                    # エンゲージメント情報
                    metrics = tweet_data.get('public_metrics', {})
                    engagement = f"\n💬 {metrics.get('reply_count', 0)} | 🔄 {metrics.get('retweet_count', 0)} | ❤️ {metrics.get('like_count', 0)} | 👀 {metrics.get('impression_count', 0)}"
                    
                    embed = {
                        "title": f"🚨 キーワード検出: {', '.join(matched_keywords)}",
                        "description": display_text + engagement,
                        "color": 0x1DA1F2,
                        "fields": [
                            {
                                "name": "👤 投稿者",
                                "value": f"[@{self.target_user}](https://twitter.com/{self.target_user})",
                                "inline": True
                            },
                            {
                                "name": "🕐 投稿時刻",
                                "value": jst_time.strftime("%m/%d %H:%M JST"),
                                "inline": True
                            },
                            {
                                "name": "🔗 リンク",
                                "value": f"[ツイートを見る](https://twitter.com/{self.target_user}/status/{tweet_id})",
                                "inline": False
                            }
                        ],
                        "footer": {
                            "text": f"Twitter監視Bot v3.0 | 実行時刻: {datetime.now(self.jst).strftime('%H:%M')}",
                            "icon_url": "https://abs.twimg.com/icons/apple-touch-icon-192x192.png"
                        },
                        "timestamp": created_at
                    }
                    
                    payload = {
                        "embeds": [embed],
                        "username": "Twitter監視Bot",
                        "avatar_url": "https://abs.twimg.com/icons/apple-touch-icon-192x192.png"
                    }
                    
                    if self.debug_mode:
                        self.log(f"📤 Discord通知データサイズ: {len(json.dumps(payload))}文字")
                    
                    # Discord API にリトライ付きで送信
                    for attempt in range(3):
                        try:
                            response = requests.post(self.webhook_url, json=payload, timeout=30)
                            
                            if self.debug_mode:
                                self.log(f"📡 Discord API Response: {response.status_code}")
                                self.log(f"📡 Discord Response Text: {response.text}")
                            
                            if response.status_code in [200, 204]:
                                self.log(f"✅ Discord通知送信成功 (試行: {attempt + 1})")
                                self.stats['notifications_sent'] += 1
                                return True
                            elif response.status_code == 429:
                                wait_time = 5 * (attempt + 1)
                                self.log(f"⚠️ Discord API制限 - {wait_time}秒待機", "WARNING")
                                time.sleep(wait_time)
                                continue
                            else:
                                self.log(f"❌ Discord通知エラー: {response.status_code} - {response.text}", "ERROR")
                                
                        except requests.exceptions.RequestException as e:
                            self.log(f"❌ Discord通知送信エラー (試行 {attempt + 1}): {e}", "ERROR")
                            if attempt < 2:
                                time.sleep(5)
                                continue
                    
                    self.stats['errors'] += 1
                    return False
                    
                except Exception as e:
                    self.log(f"❌ 通知処理中の予期しないエラー: {e}", "ERROR")
                    if self.debug_mode:
                        traceback.print_exc()
                    return False
        
            def send_summary_notification(self):
                """実行結果サマリーをDiscordに送信"""
                if not self.debug_mode:
                    return
                
                runtime = datetime.utcnow() - self.stats['start_time']
                
                embed = {
                    "title": "📊 実行結果サマリー",
                    "color": 0x00ff00 if self.stats['errors'] == 0 else 0xff9900,
                    "fields": [
                        {"name": "🔍 チェックしたツイート数", "value": str(self.stats['tweets_checked']), "inline": True},
                        {"name": "🔔 送信した通知数", "value": str(self.stats['notifications_sent']), "inline": True},
                        {"name": "🌐 API呼び出し回数", "value": str(self.stats['api_calls']), "inline": True},
                        {"name": "❌ エラー回数", "value": str(self.stats['errors']), "inline": True},
                        {"name": "⏱️ 実行時間", "value": f"{runtime.total_seconds():.1f}秒", "inline": True},
                        {"name": "🕐 実行時刻", "value": datetime.now(self.jst).strftime("%H:%M JST"), "inline": True}
                    ],
                    "footer": {"text": "デバッグモード - サマリー通知"}
                }
                
                payload = {"embeds": [embed]}
                
                try:
                    requests.post(self.webhook_url, json=payload, timeout=10)
                    self.log("📊 サマリー通知送信完了")
                except Exception as e:
                    self.log(f"⚠️ サマリー送信エラー: {e}", "WARNING")
        
            def send_error_notification(self, error_message):
                """エラー通知をDiscordに送信"""
                try:
                    embed = {
                        "title": "❌ Twitter監視Bot エラー",
                        "description": f"```\n{error_message}\n```",
                        "color": 0xff0000,
                        "fields": [
                            {"name": "🕐 発生時刻", "value": datetime.now(self.jst).strftime("%m/%d %H:%M JST"), "inline": True},
                            {"name": "🔄 次回実行", "value": "5分後", "inline": True}
                        ],
                        "footer": {"text": "GitHub Actions - エラー通知"}
                    }
                    
                    payload = {"embeds": [embed]}
                    response = requests.post(self.webhook_url, json=payload, timeout=10)
                    
                    if response.status_code in [200, 204]:
                        self.log("📢 エラー通知送信完了")
                    
                except Exception as e:
                    self.log(f"⚠️ エラー通知送信失敗: {e}", "WARNING")
        
            def run(self):
                """メイン処理"""
                try:
                    # 環境変数チェック
                    if not all([self.bearer_token, self.webhook_url, self.target_user, self.keywords]):
                        missing = []
                        if not self.bearer_token: missing.append("BEARER_TOKEN")
                        if not self.webhook_url: missing.append("DISCORD_WEBHOOK")
                        if not self.target_user: missing.append("TARGET_USER")
                        if not self.keywords: missing.append("KEYWORDS")
                        error_msg = f"必要な環境変数が設定されていません: {', '.join(missing)}"
                        self.log(f"❌ {error_msg}", "ERROR")
                        self.send_error_notification(error_msg)
                        return
                    
                    # 状態読み込み
                    state = self.load_state()
                    processed_tweets = self.load_processed_tweets()
                    
                    # ユーザーID取得
                    user_id = self.get_user_id()
                    if not user_id:
                        self.send_error_notification(f"ユーザー '{self.target_user}' のIDを取得できませんでした")
                        return
                    
                    # ツイート取得
                    tweets = self.get_recent_tweets(user_id, state.get('last_tweet_id'))
                    if tweets is None:
                        self.send_error_notification("ツイートの取得に失敗しました")
                        return
                    
                    if not tweets:
                        self.log("✅ 新しいツイートはありませんでした")
                        self.send_summary_notification()
                        return
                    
                    # 新しいツイートを時系列順で処理（古い順）
                    tweets.sort(key=lambda x: x['created_at'])
                    
                    notifications_sent = 0
                    new_last_tweet_id = state.get('last_tweet_id')
                    
                    for tweet in tweets:
                        tweet_id = tweet['id']
                        tweet_text = tweet['text']
                        
                        # 重複チェック
                        if tweet_id in processed_tweets:
                            if self.debug_mode:
                                self.log(f"⏭️ 既に処理済み: {tweet_id}")
                            continue
                        
                        # キーワードチェック
                        matched_keywords = self.check_keywords(tweet_text, self.keywords)
                        
                        if matched_keywords:
                            self.log(f"🎯 キーワード検出: {matched_keywords}")
                            if self.debug_mode:
                                self.log(f"📝 ツイート内容: {tweet_text[:100]}...")
                            
                            # クールダウンチェック（同じキーワードで短時間に複数通知を防ぐ）
                            cooldown_key = f"{'-'.join(sorted(matched_keywords))}"
                            last_notification = processed_tweets.get(f"cooldown_{cooldown_key}")
                            
                            if last_notification:
                                last_time = datetime.fromisoformat(last_notification.replace('Z', '+00:00'))
                                if (datetime.utcnow() - last_time).total_seconds() < self.notification_cooldown:
                                    self.log(f"⏳ クールダウン中: {matched_keywords}")
                                    processed_tweets[tweet_id] = datetime.utcnow().isoformat()
                                    continue
                            
                            # 通知送信
                            success = self.send_discord_notification(tweet_text, matched_keywords, tweet)
                            
                            if success:
                                notifications_sent += 1
                                processed_tweets[tweet_id] = datetime.utcnow().isoformat()
                                processed_tweets[f"cooldown_{cooldown_key}"] = datetime.utcnow().isoformat()
                                
                                self.log(f"🎉 通知送信成功: {matched_keywords}")
                            else:
                                self.log(f"❌ 通知送信失敗: {tweet_id}", "ERROR")
                        else:
                            # キーワードにマッチしなくても処理済みとして記録
                            processed_tweets[tweet_id] = datetime.utcnow().isoformat()
                            if self.debug_mode:
                                self.log(f"⏭️ キーワード未マッチ: {tweet_id}")
                        
                        # 最新のツイートIDを更新
                        new_last_tweet_id = tweet_id
                    
                    # 状態保存
                    state['last_tweet_id'] = new_last_tweet_id
                    state['total_notifications'] = state.get('total_notifications', 0) + notifications_sent
                    state['total_tweets_processed'] = state.get('total_tweets_processed', 0) + len(tweets)
                    
                    self.save_state(state)
                    self.save_processed_tweets(processed_tweets)
                    
                    # 結果出力
                    self.log(f"🎯 処理完了: {len(tweets)}件のツイートを確認, {notifications_sent}件の通知を送信")
                    self.send_summary_notification()
                    
                except Exception as e:
                    self.log(f"❌ 予期しないエラー: {e}", "ERROR")
                    if self.debug_mode:
                        traceback.print_exc()
                    self.stats['errors'] += 1
                    self.send_error_notification(str(e))
        
        # メイン実行
        if __name__ == "__main__":
            try:
                bot = TwitterMonitorBot()
                bot.run()
            except Exception as e:
                print(f"❌ 致命的エラー: {e}")
                import traceback
                traceback.print_exc()
        
        EOF
