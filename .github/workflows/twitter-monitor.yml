name: Twitter Discord Bot

on:
  schedule:
    # 10åˆ†ã”ã¨ã«å®Ÿè¡Œï¼ˆUTCã‚¿ã‚¤ãƒ ï¼‰
    - cron: '*/10 * * * *'
  # æ‰‹å‹•å®Ÿè¡Œã‚‚å¯èƒ½
  workflow_dispatch:

jobs:
  monitor-twitter:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install requests
    
    - name: Run Twitter monitor
      env:
        BEARER_TOKEN: ${{ secrets.BEARER_TOKEN }}
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        TARGET_USER: ${{ secrets.TARGET_USER }}
        KEYWORDS: ${{ secrets.KEYWORDS }}
      run: |
        python << 'EOF'
        import requests
        import os
        import json
        from datetime import datetime, timedelta
        
        def main():
            # è¨­å®šèª­ã¿è¾¼ã¿
            bearer_token = os.environ.get('BEARER_TOKEN')
            webhook_url = os.environ.get('DISCORD_WEBHOOK')
            target_user = os.environ.get('TARGET_USER')
            keywords = os.environ.get('KEYWORDS', '').split(',')
            
            if not all([bearer_token, webhook_url, target_user]):
                print("å¿…è¦ãªç’°å¢ƒå¤‰æ•°ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return
            
            # Twitter API headers
            headers = {
                'Authorization': f'Bearer {bearer_token}',
                'User-Agent': 'TwitterBot/1.0'
            }
            
            try:
                # ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’å–å¾—
                user_url = f'https://api.twitter.com/2/users/by/username/{target_user}'
                user_response = requests.get(user_url, headers=headers, timeout=30)
                
                if user_response.status_code != 200:
                    print(f"ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼: {user_response.status_code}")
                    print(user_response.text)
                    return
                
                user_data = user_response.json()
                if 'data' not in user_data:
                    print("ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    return
                
                user_id = user_data['data']['id']
                
                # éå»30åˆ†ã®ãƒ„ã‚¤ãƒ¼ãƒˆã‚’å–å¾—ï¼ˆé‡è¤‡é€šçŸ¥é˜²æ­¢ï¼‰
                end_time = datetime.utcnow()
                start_time = end_time - timedelta(minutes=30)
                
                tweets_url = f'https://api.twitter.com/2/users/{user_id}/tweets'
                params = {
                    'max_results': 10,
                    'tweet.fields': 'created_at,public_metrics',
                    'start_time': start_time.strftime('%Y-%m-%dT%H:%M:%SZ'),
                    'end_time': end_time.strftime('%Y-%m-%dT%H:%M:%SZ')
                }
                
                tweets_response = requests.get(tweets_url, headers=headers, params=params, timeout=30)
                
                if tweets_response.status_code != 200:
                    print(f"ãƒ„ã‚¤ãƒ¼ãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼: {tweets_response.status_code}")
                    print(tweets_response.text)
                    return
                
                tweets_data = tweets_response.json()
                
                if 'data' not in tweets_data:
                    print("æ–°ã—ã„ãƒ„ã‚¤ãƒ¼ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“")
                    return
                
                # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
                for tweet in tweets_data['data']:
                    tweet_text = tweet['text']
                    created_at = tweet['created_at']
                    
                    for keyword in keywords:
                        keyword = keyword.strip()
                        if keyword and keyword.lower() in tweet_text.lower():
                            send_discord_notification(
                                webhook_url, 
                                tweet_text, 
                                keyword, 
                                target_user,
                                created_at
                            )
                            print(f"é€šçŸ¥é€ä¿¡: ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ '{keyword}' æ¤œå‡º")
                            break  # 1ã¤ã®ãƒ„ã‚¤ãƒ¼ãƒˆã§è¤‡æ•°ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒãƒãƒƒãƒã—ã¦ã‚‚1å›ã ã‘é€šçŸ¥
                
            except requests.exceptions.RequestException as e:
                print(f"ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            except Exception as e:
                print(f"äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}")
        
        def send_discord_notification(webhook_url, tweet_text, keyword, username, created_at):
            """Discord Webhookã§é€šçŸ¥ã‚’é€ä¿¡"""
            embed = {
                "title": f"ğŸ”” ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã€Œ{keyword}ã€ã‚’æ¤œå‡ºï¼",
                "description": tweet_text,
                "color": 3447003,  # é’è‰²
                "fields": [
                    {
                        "name": "ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ",
                        "value": f"@{username}",
                        "inline": True
                    },
                    {
                        "name": "æŠ•ç¨¿æ™‚åˆ»",
                        "value": created_at,
                        "inline": True
                    }
                ],
                "footer": {
                    "text": "Twitterç›£è¦–Bot"
                }
            }
            
            payload = {
                "embeds": [embed]
            }
            
            try:
                response = requests.post(webhook_url, json=payload, timeout=30)
                if response.status_code not in [200, 204]:
                    print(f"Discordé€šçŸ¥ã‚¨ãƒ©ãƒ¼: {response.status_code}")
                    print(response.text)
            except Exception as e:
                print(f"Discordé€šçŸ¥é€ä¿¡ã‚¨ãƒ©ãƒ¼: {e}")
        
        if __name__ == "__main__":
            main()
        EOF
