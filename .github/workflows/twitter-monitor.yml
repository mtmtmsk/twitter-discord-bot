name: Twitter Discord Bot (æ”¹å–„ç‰ˆ)

on:
  schedule:
    # 5åˆ†ã”ã¨ã«å®Ÿè¡Œï¼ˆAPIåˆ¶é™ã‚’è€ƒæ…®ã—ã¦æœ€é©åŒ–ï¼‰
    - cron: '*/5 * * * *'
  workflow_dispatch:
    inputs:
      force_check:
        description: 'å¼·åˆ¶å®Ÿè¡Œï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰'
        required: false
        default: 'false'

jobs:
  monitor-twitter:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    # çŠ¶æ…‹ç®¡ç†ç”¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    - name: Cache bot state
      uses: actions/cache@v3
      with:
        path: |
          bot_state.json
          processed_tweets.json
        key: twitter-bot-state-${{ github.run_number }}
        restore-keys: |
          twitter-bot-state-
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install requests pytz
    
    - name: Run Twitter monitor
      env:
        BEARER_TOKEN: ${{ secrets.BEARER_TOKEN }}
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        TARGET_USER: ${{ secrets.TARGET_USER }}
        KEYWORDS: ${{ secrets.KEYWORDS }}
        # ãƒ‡ãƒãƒƒã‚°ç”¨è¨­å®š
        DEBUG_MODE: ${{ secrets.DEBUG_MODE || 'false' }}
        MAX_TWEETS_PER_RUN: ${{ secrets.MAX_TWEETS_PER_RUN || '10' }}
        NOTIFICATION_COOLDOWN: ${{ secrets.NOTIFICATION_COOLDOWN || '300' }}
      run: |
        python << 'EOF'
        import requests
        import os
        import json
        from datetime import datetime, timedelta, timezone
        import re
        import time
        import traceback
        import pytz
        
        class TwitterMonitorBot:
            def __init__(self):
                # è¨­å®šèª­ã¿è¾¼ã¿
                self.bearer_token = os.environ.get('BEARER_TOKEN')
                self.webhook_url = os.environ.get('DISCORD_WEBHOOK')
                self.target_user = os.environ.get('TARGET_USER')
                self.keywords = [k.strip() for k in os.environ.get('KEYWORDS', '').split(',') if k.strip()]
                self.debug_mode = os.environ.get('DEBUG_MODE', 'false').lower() == 'true'
                self.max_tweets_per_run = int(os.environ.get('MAX_TWEETS_PER_RUN', '10'))
                self.notification_cooldown = int(os.environ.get('NOTIFICATION_COOLDOWN', '300'))
                
                # çµ±è¨ˆæƒ…å ±
                self.stats = {
                    'tweets_checked': 0,
                    'notifications_sent': 0,
                    'api_calls': 0,
                    'errors': 0,
                    'start_time': datetime.utcnow()
                }
                
                # Twitter API headers
                self.headers = {
                    'Authorization': f'Bearer {self.bearer_token}',
                    'User-Agent': 'TwitterBot/3.0'
                }
                
                # æ—¥æœ¬æ™‚é–“è¨­å®š
                self.jst = pytz.timezone('Asia/Tokyo')
                
                self.log(f"ğŸ¤– Twitter Monitor Bot v3.0 èµ·å‹•")
                self.log(f"ğŸ¯ ç›£è¦–å¯¾è±¡: @{self.target_user}")
                self.log(f"ğŸ”‘ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: {', '.join(self.keywords)}")
                self.log(f"ğŸ› ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: {'ON' if self.debug_mode else 'OFF'}")
        
            def log(self, message, level="INFO"):
                """æ”¹å–„ã•ã‚ŒãŸãƒ­ã‚°å‡ºåŠ›"""
                timestamp = datetime.now(self.jst).strftime('%Y-%m-%d %H:%M:%S JST')
                print(f"[{timestamp}] [{level}] {message}")
        
            def load_state(self):
                """çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ï¼ˆæ°¸ç¶šåŒ–å¯¾å¿œï¼‰"""
                try:
                    with open('bot_state.json', 'r', encoding='utf-8') as f:
                        state = json.load(f)
                        self.log(f"ğŸ“‚ çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿æˆåŠŸ: last_tweet_id={state.get('last_tweet_id', 'None')}")
                        return state
                except FileNotFoundError:
                    self.log("ğŸ“‚ çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ–°è¦ä½œæˆã—ã¾ã™ã€‚")
                    return {
                        'last_tweet_id': None,
                        'last_run_time': None,
                        'total_notifications': 0,
                        'total_tweets_processed': 0
                    }
                except json.JSONDecodeError as e:
                    self.log(f"âŒ çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}", "ERROR")
                    return {}
        
            def save_state(self, state):
                """çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜"""
                try:
                    state['last_run_time'] = datetime.utcnow().isoformat()
                    with open('bot_state.json', 'w', encoding='utf-8') as f:
                        json.dump(state, f, ensure_ascii=False, indent=2)
                    self.log("ğŸ’¾ çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜å®Œäº†")
                except Exception as e:
                    self.log(f"âŒ çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}", "ERROR")
        
            def load_processed_tweets(self):
                """å‡¦ç†æ¸ˆã¿ãƒ„ã‚¤ãƒ¼ãƒˆãƒªã‚¹ãƒˆã®èª­ã¿è¾¼ã¿"""
                try:
                    with open('processed_tweets.json', 'r', encoding='utf-8') as f:
                        data = json.load(f)
                        # 24æ™‚é–“ä»¥ä¸Šå¤ã„è¨˜éŒ²ã¯å‰Šé™¤
                        cutoff_time = datetime.utcnow() - timedelta(hours=24)
                        filtered_data = {
                            tweet_id: timestamp for tweet_id, timestamp in data.items()
                            if datetime.fromisoformat(timestamp.replace('Z', '+00:00')) > cutoff_time
                        }
                        self.log(f"ğŸ§¹ å‡¦ç†æ¸ˆã¿ãƒ„ã‚¤ãƒ¼ãƒˆ: {len(data)} â†’ {len(filtered_data)} (24æ™‚é–“ã§ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—)")
                        return filtered_data
                except FileNotFoundError:
                    self.log("ğŸ“‚ å‡¦ç†æ¸ˆã¿ãƒ„ã‚¤ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ–°è¦ä½œæˆ")
                    return {}
                except Exception as e:
                    self.log(f"âŒ å‡¦ç†æ¸ˆã¿ãƒ„ã‚¤ãƒ¼ãƒˆèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}", "ERROR")
                    return {}
        
            def save_processed_tweets(self, processed_tweets):
                """å‡¦ç†æ¸ˆã¿ãƒ„ã‚¤ãƒ¼ãƒˆãƒªã‚¹ãƒˆã®ä¿å­˜"""
                try:
                    with open('processed_tweets.json', 'w', encoding='utf-8') as f:
                        json.dump(processed_tweets, f, ensure_ascii=False, indent=2)
                except Exception as e:
                    self.log(f"âŒ å‡¦ç†æ¸ˆã¿ãƒ„ã‚¤ãƒ¼ãƒˆä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}", "ERROR")
        
            def make_api_request(self, url, params=None, max_retries=3):
                """API ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼ˆãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ä»˜ãï¼‰"""
                self.stats['api_calls'] += 1
                
                for attempt in range(max_retries):
                    try:
                        if self.debug_mode:
                            self.log(f"ğŸŒ API Request (è©¦è¡Œ {attempt + 1}): {url}")
                        
                        response = requests.get(url, headers=self.headers, params=params, timeout=30)
                        
                        if response.status_code == 200:
                            return response
                        elif response.status_code == 429:
                            self.log(f"âš ï¸ APIåˆ¶é™ã«é”ã—ã¾ã—ãŸ (è©¦è¡Œ {attempt + 1})", "WARNING")
                            if attempt < max_retries - 1:
                                wait_time = (2 ** attempt) * 60  # æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ï¼ˆåˆ†ï¼‰
                                self.log(f"â³ {wait_time}ç§’å¾…æ©Ÿä¸­...")
                                time.sleep(wait_time)
                                continue
                            else:
                                self.log("âŒ APIåˆ¶é™ã«ã‚ˆã‚Šå‡¦ç†ã‚’ä¸­æ–­", "ERROR")
                                return None
                        elif response.status_code == 401:
                            self.log("âŒ èªè¨¼ã‚¨ãƒ©ãƒ¼: Bearer Tokenã‚’ç¢ºèªã—ã¦ãã ã•ã„", "ERROR")
                            return None
                        else:
                            self.log(f"âŒ API ã‚¨ãƒ©ãƒ¼: {response.status_code} - {response.text}", "ERROR")
                            if attempt < max_retries - 1:
                                time.sleep(5)
                                continue
                            return None
                            
                    except requests.exceptions.Timeout:
                        self.log(f"â±ï¸ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ (è©¦è¡Œ {attempt + 1})", "WARNING")
                        if attempt < max_retries - 1:
                            time.sleep(10)
                            continue
                    except requests.exceptions.RequestException as e:
                        self.log(f"ğŸ“¡ ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼ (è©¦è¡Œ {attempt + 1}): {e}", "WARNING")
                        if attempt < max_retries - 1:
                            time.sleep(5)
                            continue
                
                self.stats['errors'] += 1
                return None
        
            def get_user_id(self):
                """ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’å–å¾—"""
                user_url = f'https://api.twitter.com/2/users/by/username/{self.target_user}'
                response = self.make_api_request(user_url)
                
                if not response:
                    return None
                
                try:
                    user_data = response.json()
                    if 'data' not in user_data:
                        self.log(f"âŒ ãƒ¦ãƒ¼ã‚¶ãƒ¼ '{self.target_user}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", "ERROR")
                        return None
                    
                    user_id = user_data['data']['id']
                    self.log(f"âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼IDå–å¾—: {user_id}")
                    return user_id
                except json.JSONDecodeError as e:
                    self.log(f"âŒ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿è§£æã‚¨ãƒ©ãƒ¼: {e}", "ERROR")
                    return None
        
            def get_recent_tweets(self, user_id, since_id=None):
                """æœ€æ–°ãƒ„ã‚¤ãƒ¼ãƒˆã‚’å–å¾—ï¼ˆæ”¹å–„ç‰ˆï¼‰"""
                tweets_url = f'https://api.twitter.com/2/users/{user_id}/tweets'
                
                params = {
                    'max_results': min(self.max_tweets_per_run, 100),
                    'tweet.fields': 'created_at,public_metrics,context_annotations,lang',
                    'exclude': 'retweets,replies'
                }
                
                # å‰å›å‡¦ç†ã—ãŸãƒ„ã‚¤ãƒ¼ãƒˆIDãŒã‚ã‚‹å ´åˆã¯ã€ãã‚Œä»¥é™ã®ã¿å–å¾—
                if since_id:
                    params['since_id'] = since_id
                    self.log(f"ğŸ“Š since_idæŒ‡å®š: {since_id}")
                else:
                    # since_idãŒãªã„å ´åˆã¯éå»10åˆ†ã®ãƒ„ã‚¤ãƒ¼ãƒˆã®ã¿
                    end_time = datetime.utcnow()
                    start_time = end_time - timedelta(minutes=10)
                    params['start_time'] = start_time.strftime('%Y-%m-%dT%H:%M:%SZ')
                    params['end_time'] = end_time.strftime('%Y-%m-%dT%H:%M:%SZ')
                
                response = self.make_api_request(tweets_url, params)
                
                if not response:
                    return None
                
                try:
                    tweets_data = response.json()
                    
                    if 'data' not in tweets_data or not tweets_data['data']:
                        self.log("â„¹ï¸ æ–°ã—ã„ãƒ„ã‚¤ãƒ¼ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“")
                        return []
                    
                    tweets = tweets_data['data']
                    self.log(f"ğŸ“ {len(tweets)}ä»¶ã®ãƒ„ã‚¤ãƒ¼ãƒˆã‚’å–å¾—")
                    self.stats['tweets_checked'] += len(tweets)
                    
                    return tweets
                except json.JSONDecodeError as e:
                    self.log(f"âŒ ãƒ„ã‚¤ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿è§£æã‚¨ãƒ©ãƒ¼: {e}", "ERROR")
                    return None
        
            def check_keywords(self, text, keywords):
                """ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯ï¼ˆæ”¹å–„ç‰ˆï¼‰"""
                matched_keywords = []
                text_lower = text.lower()
                
                for keyword in keywords:
                    # å®Œå…¨ä¸€è‡´ã€éƒ¨åˆ†ä¸€è‡´ã€æ­£è¦è¡¨ç¾å¯¾å¿œ
                    if re.search(re.escape(keyword.lower()), text_lower):
                        matched_keywords.append(keyword)
                
                return matched_keywords
        
            def send_discord_notification(self, tweet_text, matched_keywords, tweet_data):
                """Discordé€šçŸ¥é€ä¿¡ï¼ˆã‚¨ãƒ©ãƒ¼å‡¦ç†å¼·åŒ–ç‰ˆï¼‰"""
                try:
                    tweet_id = tweet_data['id']
                    created_at = tweet_data['created_at']
                    
                    # UTC -> JSTå¤‰æ›
                    utc_time = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                    jst_time = utc_time.astimezone(self.jst)
                    
                    # ãƒ†ã‚­ã‚¹ãƒˆé•·åˆ¶é™
                    display_text = tweet_text if len(tweet_text) <= 300 else tweet_text[:300] + "..."
                    
                    # ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆæƒ…å ±
                    metrics = tweet_data.get('public_metrics', {})
                    engagement = f"\nğŸ’¬ {metrics.get('reply_count', 0)} | ğŸ”„ {metrics.get('retweet_count', 0)} | â¤ï¸ {metrics.get('like_count', 0)} | ğŸ‘€ {metrics.get('impression_count', 0)}"
                    
                    embed = {
                        "title": f"ğŸš¨ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œå‡º: {', '.join(matched_keywords)}",
                        "description": display_text + engagement,
                        "color": 0x1DA1F2,
                        "fields": [
                            {
                                "name": "ğŸ‘¤ æŠ•ç¨¿è€…",
                                "value": f"[@{self.target_user}](https://twitter.com/{self.target_user})",
                                "inline": True
                            },
                            {
                                "name": "ğŸ• æŠ•ç¨¿æ™‚åˆ»",
                                "value": jst_time.strftime("%m/%d %H:%M JST"),
                                "inline": True
                            },
                            {
                                "name": "ğŸ”— ãƒªãƒ³ã‚¯",
                                "value": f"[ãƒ„ã‚¤ãƒ¼ãƒˆã‚’è¦‹ã‚‹](https://twitter.com/{self.target_user}/status/{tweet_id})",
                                "inline": False
                            }
                        ],
                        "footer": {
                            "text": f"Twitterç›£è¦–Bot v3.0 | å®Ÿè¡Œæ™‚åˆ»: {datetime.now(self.jst).strftime('%H:%M')}",
                            "icon_url": "https://abs.twimg.com/icons/apple-touch-icon-192x192.png"
                        },
                        "timestamp": created_at
                    }
                    
                    payload = {
                        "embeds": [embed],
                        "username": "Twitterç›£è¦–Bot",
                        "avatar_url": "https://abs.twimg.com/icons/apple-touch-icon-192x192.png"
                    }
                    
                    # Discord API ã«ãƒªãƒˆãƒ©ã‚¤ä»˜ãã§é€ä¿¡
                    for attempt in range(3):
                        try:
                            response = requests.post(self.webhook_url, json=payload, timeout=30)
                            if response.status_code in [200, 204]:
                                self.log(f"âœ… Discordé€šçŸ¥é€ä¿¡æˆåŠŸ (è©¦è¡Œ: {attempt + 1})")
                                self.stats['notifications_sent'] += 1
                                return True
                            elif response.status_code == 429:
                                wait_time = 5 * (attempt + 1)
                                self.log(f"âš ï¸ Discord APIåˆ¶é™ - {wait_time}ç§’å¾…æ©Ÿ", "WARNING")
                                time.sleep(wait_time)
                                continue
                            else:
                                self.log(f"âŒ Discordé€šçŸ¥ã‚¨ãƒ©ãƒ¼: {response.status_code}", "ERROR")
                                
                        except requests.exceptions.RequestException as e:
                            self.log(f"âŒ Discordé€šçŸ¥é€ä¿¡ã‚¨ãƒ©ãƒ¼ (è©¦è¡Œ {attempt + 1}): {e}", "ERROR")
                            if attempt < 2:
                                time.sleep(5)
                                continue
                    
                    self.stats['errors'] += 1
                    return False
                    
                except Exception as e:
                    self.log(f"âŒ é€šçŸ¥å‡¦ç†ä¸­ã®äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}", "ERROR")
                    traceback.print_exc()
                    return False
        
            def send_summary_notification(self):
                """å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼ã‚’Discordã«é€ä¿¡"""
                if not self.debug_mode:
                    return
                
                runtime = datetime.utcnow() - self.stats['start_time']
                
                embed = {
                    "title": "ğŸ“Š å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼",
                    "color": 0x00ff00 if self.stats['errors'] == 0 else 0xff9900,
                    "fields": [
                        {"name": "ğŸ” ãƒã‚§ãƒƒã‚¯ã—ãŸãƒ„ã‚¤ãƒ¼ãƒˆæ•°", "value": str(self.stats['tweets_checked']), "inline": True},
                        {"name": "ğŸ”” é€ä¿¡ã—ãŸé€šçŸ¥æ•°", "value": str(self.stats['notifications_sent']), "inline": True},
                        {"name": "ğŸŒ APIå‘¼ã³å‡ºã—å›æ•°", "value": str(self.stats['api_calls']), "inline": True},
                        {"name": "âŒ ã‚¨ãƒ©ãƒ¼å›æ•°", "value": str(self.stats['errors']), "inline": True},
                        {"name": "â±ï¸ å®Ÿè¡Œæ™‚é–“", "value": f"{runtime.total_seconds():.1f}ç§’", "inline": True},
                        {"name": "ğŸ• å®Ÿè¡Œæ™‚åˆ»", "value": datetime.now(self.jst).strftime("%H:%M JST"), "inline": True}
                    ],
                    "footer": {"text": "ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ - ã‚µãƒãƒªãƒ¼é€šçŸ¥"}
                }
                
                payload = {"embeds": [embed]}
                
                try:
                    requests.post(self.webhook_url, json=payload, timeout=10)
                except:
                    pass  # ã‚µãƒãƒªãƒ¼é€ä¿¡ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
        
            def run(self):
                """ãƒ¡ã‚¤ãƒ³å‡¦ç†"""
                try:
                    # ç’°å¢ƒå¤‰æ•°ãƒã‚§ãƒƒã‚¯
                    if not all([self.bearer_token, self.webhook_url, self.target_user, self.keywords]):
                        self.log("âŒ å¿…è¦ãªç’°å¢ƒå¤‰æ•°ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“", "ERROR")
                        return
                    
                    # çŠ¶æ…‹èª­ã¿è¾¼ã¿
                    state = self.load_state()
                    processed_tweets = self.load_processed_tweets()
                    
                    # ãƒ¦ãƒ¼ã‚¶ãƒ¼IDå–å¾—
                    user_id = self.get_user_id()
                    if not user_id:
                        return
                    
                    # ãƒ„ã‚¤ãƒ¼ãƒˆå–å¾—
                    tweets = self.get_recent_tweets(user_id, state.get('last_tweet_id'))
                    if tweets is None:
                        return
                    
                    if not tweets:
                        self.log("âœ… æ–°ã—ã„ãƒ„ã‚¤ãƒ¼ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
                        self.send_summary_notification()
                        return
                    
                    # æ–°ã—ã„ãƒ„ã‚¤ãƒ¼ãƒˆã‚’æ™‚ç³»åˆ—é †ã§å‡¦ç†ï¼ˆå¤ã„é †ï¼‰
                    tweets.sort(key=lambda x: x['created_at'])
                    
                    notifications_sent = 0
                    new_last_tweet_id = state.get('last_tweet_id')
                    
                    for tweet in tweets:
                        tweet_id = tweet['id']
                        tweet_text = tweet['text']
                        
                        # é‡è¤‡ãƒã‚§ãƒƒã‚¯
                        if tweet_id in processed_tweets:
                            self.log(f"â­ï¸ æ—¢ã«å‡¦ç†æ¸ˆã¿: {tweet_id}")
                            continue
                        
                        # è¨€èªãƒã‚§ãƒƒã‚¯ï¼ˆæ—¥æœ¬èªãƒ„ã‚¤ãƒ¼ãƒˆã®ã¿å¯¾è±¡ã«ã™ã‚‹å ´åˆï¼‰
                        # if tweet.get('lang') != 'ja':
                        #     continue
                        
                        # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
                        matched_keywords = self.check_keywords(tweet_text, self.keywords)
                        
                        if matched_keywords:
                            # ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯ï¼ˆåŒã˜ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§çŸ­æ™‚é–“ã«è¤‡æ•°é€šçŸ¥ã‚’é˜²ãï¼‰
                            cooldown_key = f"{'-'.join(sorted(matched_keywords))}"
                            last_notification = processed_tweets.get(f"cooldown_{cooldown_key}")
                            
                            if last_notification:
                                last_time = datetime.fromisoformat(last_notification.replace('Z', '+00:00'))
                                if (datetime.utcnow() - last_time).total_seconds() < self.notification_cooldown:
                                    self.log(f"â³ ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­: {matched_keywords}")
                                    processed_tweets[tweet_id] = datetime.utcnow().isoformat()
                                    continue
                            
                            # é€šçŸ¥é€ä¿¡
                            success = self.send_discord_notification(tweet_text, matched_keywords, tweet)
                            
                            if success:
                                notifications_sent += 1
                                processed_tweets[tweet_id] = datetime.utcnow().isoformat()
                                processed_tweets[f"cooldown_{cooldown_key}"] = datetime.utcnow().isoformat()
                                
                                self.log(f"ğŸ‰ é€šçŸ¥é€ä¿¡: {matched_keywords}")
                                self.log(f"   ãƒ„ã‚¤ãƒ¼ãƒˆ: {tweet_text[:50]}...")
                            else:
                                self.log(f"âŒ é€šçŸ¥é€ä¿¡å¤±æ•—: {tweet_id}")
                        else:
                            # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«ãƒãƒƒãƒã—ãªãã¦ã‚‚å‡¦ç†æ¸ˆã¿ã¨ã—ã¦è¨˜éŒ²
                            processed_tweets[tweet_id] = datetime.utcnow().isoformat()
                        
                        # æœ€æ–°ã®ãƒ„ã‚¤ãƒ¼ãƒˆIDã‚’æ›´æ–°
                        new_last_tweet_id = tweet_id
                    
                    # çŠ¶æ…‹ä¿å­˜
                    state['last_tweet_id'] = new_last_tweet_id
                    state['total_notifications'] = state.get('total_notifications', 0) + notifications_sent
                    state['total_tweets_processed'] = state.get('total_tweets_processed', 0) + len(tweets)
                    
                    self.save_state(state)
                    self.save_processed_tweets(processed_tweets)
                    
                    # çµæœå‡ºåŠ›
                    self.log(f"ğŸ¯ å‡¦ç†å®Œäº†: {len(tweets)}ä»¶ã®ãƒ„ã‚¤ãƒ¼ãƒˆã‚’ç¢ºèª, {notifications_sent}ä»¶ã®é€šçŸ¥ã‚’é€ä¿¡")
                    self.send_summary_notification()
                    
                except Exception as e:
                    self.log(f"âŒ äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}", "ERROR")
                    traceback.print_exc()
                    self.stats['errors'] += 1
                    
                    # ã‚¨ãƒ©ãƒ¼é€šçŸ¥
                    try:
                        error_embed = {
                            "title": "ğŸš¨ Twitter Bot ã‚¨ãƒ©ãƒ¼",
                            "description": f"```{str(e)[:1000]}```",
                            "color": 0xff0000,
                            "timestamp": datetime.utcnow().isoformat()
                        }
                        requests.post(self.webhook_url, json={"embeds": [error_embed]}, timeout=10)
                    except:
                        pass
        
        # ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ
        if __name__ == "__main__":
            bot = TwitterMonitorBot()
            bot.run()
        EOF
