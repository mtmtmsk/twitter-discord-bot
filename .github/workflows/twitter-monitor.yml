name: Twitter Discord Bot (Improved)

on:
  schedule:
    # 3分ごとに実行（より頻繁にチェック）
    - cron: '*/3 * * * *'
  workflow_dispatch:

jobs:
  monitor-twitter:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install requests
    
    - name: Run Twitter monitor
      env:
        BEARER_TOKEN: ${{ secrets.BEARER_TOKEN }}
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        TARGET_USER: ${{ secrets.TARGET_USER }}
        KEYWORDS: ${{ secrets.KEYWORDS }}
        # 新しい環境変数：最後に通知したツイートID保存用
        LAST_TWEET_ID: ${{ secrets.LAST_TWEET_ID }}
      run: |
        python << 'EOF'
        import requests
        import os
        import json
        from datetime import datetime, timedelta
        import re
        
        def main():
            # 設定読み込み
            bearer_token = os.environ.get('BEARER_TOKEN')
            webhook_url = os.environ.get('DISCORD_WEBHOOK')
            target_user = os.environ.get('TARGET_USER')
            keywords = [k.strip() for k in os.environ.get('KEYWORDS', '').split(',') if k.strip()]
            
            if not all([bearer_token, webhook_url, target_user, keywords]):
                print("❌ 必要な環境変数が設定されていません")
                return
            
            print(f"🔍 監視対象: @{target_user}")
            print(f"🔑 キーワード: {', '.join(keywords)}")
            
            # Twitter API headers
            headers = {
                'Authorization': f'Bearer {bearer_token}',
                'User-Agent': 'TwitterBot/2.0'
            }
            
            try:
                # ユーザーIDを取得
                user_url = f'https://api.twitter.com/2/users/by/username/{target_user}'
                print(f"📡 ユーザー情報取得中...")
                user_response = requests.get(user_url, headers=headers, timeout=30)
                
                if user_response.status_code == 429:
                    print("⚠️ API制限に達しました。次回の実行まで待機します。")
                    return
                elif user_response.status_code == 401:
                    print("❌ Bearer Tokenが無効です。")
                    return
                elif user_response.status_code != 200:
                    print(f"❌ ユーザー取得エラー: {user_response.status_code}")
                    return
                
                user_data = user_response.json()
                if 'data' not in user_data:
                    print(f"❌ ユーザー '{target_user}' が見つかりません")
                    return
                
                user_id = user_data['data']['id']
                print(f"✅ ユーザーID取得完了: {user_id}")
                
                # 過去15分のツイートを取得（実行間隔より長めに設定）
                end_time = datetime.utcnow()
                start_time = end_time - timedelta(minutes=15)
                
                tweets_url = f'https://api.twitter.com/2/users/{user_id}/tweets'
                params = {
                    'max_results': 20,  # 取得数を増加
                    'tweet.fields': 'created_at,public_metrics,context_annotations',
                    'start_time': start_time.strftime('%Y-%m-%dT%H:%M:%SZ'),
                    'end_time': end_time.strftime('%Y-%m-%dT%H:%M:%SZ'),
                    'exclude': 'retweets,replies'
                }
                
                print(f"📡 ツイート取得中 ({start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')} UTC)...")
                tweets_response = requests.get(tweets_url, headers=headers, params=params, timeout=30)
                
                if tweets_response.status_code == 429:
                    print("⚠️ API制限に達しました。")
                    return
                elif tweets_response.status_code != 200:
                    print(f"❌ ツイート取得エラー: {tweets_response.status_code}")
                    return
                
                tweets_data = tweets_response.json()
                
                if 'data' not in tweets_data or not tweets_data['data']:
                    print("ℹ️ 指定期間内に新しいツイートはありません")
                    return
                
                print(f"📝 {len(tweets_data['data'])}件のツイートを確認中...")
                
                # 重複通知防止のため、処理済みツイートを記録
                # 実際の実装では、GitHub Actionsのキャッシュやファイル保存を使用
                processed_tweets = []
                
                # キーワードチェック
                notifications_sent = 0
                for tweet in tweets_data['data']:
                    tweet_text = tweet['text']
                    tweet_id = tweet['id']
                    created_at = tweet['created_at']
                    
                    # 重複チェック
                    if tweet_id in processed_tweets:
                        continue
                    
                    # 各キーワードをチェック（大文字小文字を区別しない）
                    matched_keywords = []
                    for keyword in keywords:
                        if re.search(re.escape(keyword.lower()), tweet_text.lower()):
                            matched_keywords.append(keyword)
                    
                    if matched_keywords:
                        # より詳細な通知情報を含める
                        success = send_discord_notification(
                            webhook_url, 
                            tweet_text, 
                            matched_keywords, 
                            target_user,
                            created_at,
                            f"https://twitter.com/{target_user}/status/{tweet_id}",
                            tweet  # ツイート全体の情報を渡す
                        )
                        
                        if success:
                            notifications_sent += 1
                            processed_tweets.append(tweet_id)
                            print(f"🔔 通知送信成功: キーワード {matched_keywords} 検出")
                            print(f"   ツイートID: {tweet_id}")
                            print(f"   ツイート: {tweet_text[:50]}...")
                        else:
                            print(f"❌ 通知送信失敗: ツイートID {tweet_id}")
                
                if notifications_sent == 0:
                    print("✅ キーワードにマッチする新しいツイートはありませんでした")
                else:
                    print(f"🎉 {notifications_sent}件の通知を送信しました")
                
            except requests.exceptions.Timeout:
                print("⏱️ タイムアウトエラー: APIの応答が遅すぎます")
            except requests.exceptions.ConnectionError:
                print("🌐 接続エラー: インターネット接続を確認してください")
            except requests.exceptions.RequestException as e:
                print(f"📡 リクエストエラー: {e}")
            except json.JSONDecodeError as e:
                print(f"📄 JSON解析エラー: {e}")
            except Exception as e:
                print(f"❌ 予期しないエラー: {e}")
                import traceback
                traceback.print_exc()
        
        def send_discord_notification(webhook_url, tweet_text, keywords, username, created_at, tweet_url, tweet_data):
            """Discord Webhookで通知を送信（エラー処理強化版）"""
            
            try:
                # ツイート時刻を日本時間に変換
                utc_time = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                jst_time = utc_time + timedelta(hours=9)
                
                # 長いツイートは省略
                display_text = tweet_text if len(tweet_text) <= 200 else tweet_text[:200] + "..."
                
                # ツイートのエンゲージメント情報を追加
                metrics = tweet_data.get('public_metrics', {})
                engagement_info = ""
                if metrics:
                    engagement_info = f"\n💬 {metrics.get('reply_count', 0)} 🔄 {metrics.get('retweet_count', 0)} ❤️ {metrics.get('like_count', 0)}"
                
                embed = {
                    "title": f"🔔 キーワード検出: {', '.join(keywords)}",
                    "description": display_text + engagement_info,
                    "color": 0x1DA1F2,
                    "fields": [
                        {
                            "name": "👤 アカウント",
                            "value": f"[@{username}](https://twitter.com/{username})",
                            "inline": True
                        },
                        {
                            "name": "🕐 投稿時刻",
                            "value": jst_time.strftime("%m/%d %H:%M JST"),
                            "inline": True
                        },
                        {
                            "name": "🔗 ツイートリンク",
                            "value": f"[ツイートを見る]({tweet_url})",
                            "inline": False
                        }
                    ],
                    "footer": {
                        "text": "Twitter監視Bot v2.1",
                        "icon_url": "https://abs.twimg.com/icons/apple-touch-icon-192x192.png"
                    },
                    "timestamp": created_at
                }
                
                payload = {
                    "embeds": [embed],
                    "username": "Twitter監視Bot",
                    "avatar_url": "https://abs.twimg.com/icons/apple-touch-icon-192x192.png"
                }
                
                # リトライ機能付きで送信
                max_retries = 3
                for attempt in range(max_retries):
                    try:
                        response = requests.post(webhook_url, json=payload, timeout=30)
                        if response.status_code in [200, 204]:
                            print(f"✅ Discord通知送信成功 (試行回数: {attempt + 1})")
                            return True
                        elif response.status_code == 429:
                            print(f"⚠️ Discord API制限 - 再試行 {attempt + 1}/{max_retries}")
                            if attempt < max_retries - 1:
                                import time
                                time.sleep(2 ** attempt)  # 指数バックオフ
                                continue
                        else:
                            print(f"❌ Discord通知エラー: {response.status_code}")
                            print(f"レスポンス: {response.text}")
                            
                    except requests.exceptions.Timeout:
                        print(f"⏱️ Discord通知タイムアウト - 試行 {attempt + 1}/{max_retries}")
                        if attempt < max_retries - 1:
                            continue
                    except requests.exceptions.RequestException as e:
                        print(f"❌ Discord通知送信エラー (試行 {attempt + 1}): {e}")
                        if attempt < max_retries - 1:
                            continue
                
                return False
                
            except Exception as e:
                print(f"❌ 通知処理中のエラー: {e}")
                return False
        
        if __name__ == "__main__":
            main()
        EOF
