name: Twitter Discord Bot (Improved)

on:
  schedule:
    # 3åˆ†ã”ã¨ã«å®Ÿè¡Œï¼ˆã‚ˆã‚Šé »ç¹ã«ãƒã‚§ãƒƒã‚¯ï¼‰
    - cron: '*/3 * * * *'
  workflow_dispatch:

jobs:
  monitor-twitter:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install requests
    
    - name: Run Twitter monitor
      env:
        BEARER_TOKEN: ${{ secrets.BEARER_TOKEN }}
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        TARGET_USER: ${{ secrets.TARGET_USER }}
        KEYWORDS: ${{ secrets.KEYWORDS }}
        # æ–°ã—ã„ç’°å¢ƒå¤‰æ•°ï¼šæœ€å¾Œã«é€šçŸ¥ã—ãŸãƒ„ã‚¤ãƒ¼ãƒˆIDä¿å­˜ç”¨
        LAST_TWEET_ID: ${{ secrets.LAST_TWEET_ID }}
      run: |
        python << 'EOF'
        import requests
        import os
        import json
        from datetime import datetime, timedelta
        import re
        
        def main():
            # è¨­å®šèª­ã¿è¾¼ã¿
            bearer_token = os.environ.get('BEARER_TOKEN')
            webhook_url = os.environ.get('DISCORD_WEBHOOK')
            target_user = os.environ.get('TARGET_USER')
            keywords = [k.strip() for k in os.environ.get('KEYWORDS', '').split(',') if k.strip()]
            
            if not all([bearer_token, webhook_url, target_user, keywords]):
                print("âŒ å¿…è¦ãªç’°å¢ƒå¤‰æ•°ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return
            
            print(f"ğŸ” ç›£è¦–å¯¾è±¡: @{target_user}")
            print(f"ğŸ”‘ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: {', '.join(keywords)}")
            
            # Twitter API headers
            headers = {
                'Authorization': f'Bearer {bearer_token}',
                'User-Agent': 'TwitterBot/2.0'
            }
            
            try:
                # ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’å–å¾—
                user_url = f'https://api.twitter.com/2/users/by/username/{target_user}'
                print(f"ğŸ“¡ ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—ä¸­...")
                user_response = requests.get(user_url, headers=headers, timeout=30)
                
                if user_response.status_code == 429:
                    print("âš ï¸ APIåˆ¶é™ã«é”ã—ã¾ã—ãŸã€‚æ¬¡å›ã®å®Ÿè¡Œã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚")
                    return
                elif user_response.status_code == 401:
                    print("âŒ Bearer TokenãŒç„¡åŠ¹ã§ã™ã€‚")
                    return
                elif user_response.status_code != 200:
                    print(f"âŒ ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼: {user_response.status_code}")
                    return
                
                user_data = user_response.json()
                if 'data' not in user_data:
                    print(f"âŒ ãƒ¦ãƒ¼ã‚¶ãƒ¼ '{target_user}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    return
                
                user_id = user_data['data']['id']
                print(f"âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼IDå–å¾—å®Œäº†: {user_id}")
                
                # éå»15åˆ†ã®ãƒ„ã‚¤ãƒ¼ãƒˆã‚’å–å¾—ï¼ˆå®Ÿè¡Œé–“éš”ã‚ˆã‚Šé•·ã‚ã«è¨­å®šï¼‰
                end_time = datetime.utcnow()
                start_time = end_time - timedelta(minutes=15)
                
                tweets_url = f'https://api.twitter.com/2/users/{user_id}/tweets'
                params = {
                    'max_results': 20,  # å–å¾—æ•°ã‚’å¢—åŠ 
                    'tweet.fields': 'created_at,public_metrics,context_annotations',
                    'start_time': start_time.strftime('%Y-%m-%dT%H:%M:%SZ'),
                    'end_time': end_time.strftime('%Y-%m-%dT%H:%M:%SZ'),
                    'exclude': 'retweets,replies'
                }
                
                print(f"ğŸ“¡ ãƒ„ã‚¤ãƒ¼ãƒˆå–å¾—ä¸­ ({start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')} UTC)...")
                tweets_response = requests.get(tweets_url, headers=headers, params=params, timeout=30)
                
                if tweets_response.status_code == 429:
                    print("âš ï¸ APIåˆ¶é™ã«é”ã—ã¾ã—ãŸã€‚")
                    return
                elif tweets_response.status_code != 200:
                    print(f"âŒ ãƒ„ã‚¤ãƒ¼ãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼: {tweets_response.status_code}")
                    return
                
                tweets_data = tweets_response.json()
                
                if 'data' not in tweets_data or not tweets_data['data']:
                    print("â„¹ï¸ æŒ‡å®šæœŸé–“å†…ã«æ–°ã—ã„ãƒ„ã‚¤ãƒ¼ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“")
                    return
                
                print(f"ğŸ“ {len(tweets_data['data'])}ä»¶ã®ãƒ„ã‚¤ãƒ¼ãƒˆã‚’ç¢ºèªä¸­...")
                
                # é‡è¤‡é€šçŸ¥é˜²æ­¢ã®ãŸã‚ã€å‡¦ç†æ¸ˆã¿ãƒ„ã‚¤ãƒ¼ãƒˆã‚’è¨˜éŒ²
                # å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€GitHub Actionsã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚„ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã‚’ä½¿ç”¨
                processed_tweets = []
                
                # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
                notifications_sent = 0
                for tweet in tweets_data['data']:
                    tweet_text = tweet['text']
                    tweet_id = tweet['id']
                    created_at = tweet['created_at']
                    
                    # é‡è¤‡ãƒã‚§ãƒƒã‚¯
                    if tweet_id in processed_tweets:
                        continue
                    
                    # å„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆå¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„ï¼‰
                    matched_keywords = []
                    for keyword in keywords:
                        if re.search(re.escape(keyword.lower()), tweet_text.lower()):
                            matched_keywords.append(keyword)
                    
                    if matched_keywords:
                        # ã‚ˆã‚Šè©³ç´°ãªé€šçŸ¥æƒ…å ±ã‚’å«ã‚ã‚‹
                        success = send_discord_notification(
                            webhook_url, 
                            tweet_text, 
                            matched_keywords, 
                            target_user,
                            created_at,
                            f"https://twitter.com/{target_user}/status/{tweet_id}",
                            tweet  # ãƒ„ã‚¤ãƒ¼ãƒˆå…¨ä½“ã®æƒ…å ±ã‚’æ¸¡ã™
                        )
                        
                        if success:
                            notifications_sent += 1
                            processed_tweets.append(tweet_id)
                            print(f"ğŸ”” é€šçŸ¥é€ä¿¡æˆåŠŸ: ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ {matched_keywords} æ¤œå‡º")
                            print(f"   ãƒ„ã‚¤ãƒ¼ãƒˆID: {tweet_id}")
                            print(f"   ãƒ„ã‚¤ãƒ¼ãƒˆ: {tweet_text[:50]}...")
                        else:
                            print(f"âŒ é€šçŸ¥é€ä¿¡å¤±æ•—: ãƒ„ã‚¤ãƒ¼ãƒˆID {tweet_id}")
                
                if notifications_sent == 0:
                    print("âœ… ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«ãƒãƒƒãƒã™ã‚‹æ–°ã—ã„ãƒ„ã‚¤ãƒ¼ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
                else:
                    print(f"ğŸ‰ {notifications_sent}ä»¶ã®é€šçŸ¥ã‚’é€ä¿¡ã—ã¾ã—ãŸ")
                
            except requests.exceptions.Timeout:
                print("â±ï¸ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼: APIã®å¿œç­”ãŒé…ã™ãã¾ã™")
            except requests.exceptions.ConnectionError:
                print("ğŸŒ æ¥ç¶šã‚¨ãƒ©ãƒ¼: ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„")
            except requests.exceptions.RequestException as e:
                print(f"ğŸ“¡ ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            except json.JSONDecodeError as e:
                print(f"ğŸ“„ JSONè§£æã‚¨ãƒ©ãƒ¼: {e}")
            except Exception as e:
                print(f"âŒ äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}")
                import traceback
                traceback.print_exc()
        
        def send_discord_notification(webhook_url, tweet_text, keywords, username, created_at, tweet_url, tweet_data):
            """Discord Webhookã§é€šçŸ¥ã‚’é€ä¿¡ï¼ˆã‚¨ãƒ©ãƒ¼å‡¦ç†å¼·åŒ–ç‰ˆï¼‰"""
            
            try:
                # ãƒ„ã‚¤ãƒ¼ãƒˆæ™‚åˆ»ã‚’æ—¥æœ¬æ™‚é–“ã«å¤‰æ›
                utc_time = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                jst_time = utc_time + timedelta(hours=9)
                
                # é•·ã„ãƒ„ã‚¤ãƒ¼ãƒˆã¯çœç•¥
                display_text = tweet_text if len(tweet_text) <= 200 else tweet_text[:200] + "..."
                
                # ãƒ„ã‚¤ãƒ¼ãƒˆã®ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆæƒ…å ±ã‚’è¿½åŠ 
                metrics = tweet_data.get('public_metrics', {})
                engagement_info = ""
                if metrics:
                    engagement_info = f"\nğŸ’¬ {metrics.get('reply_count', 0)} ğŸ”„ {metrics.get('retweet_count', 0)} â¤ï¸ {metrics.get('like_count', 0)}"
                
                embed = {
                    "title": f"ğŸ”” ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œå‡º: {', '.join(keywords)}",
                    "description": display_text + engagement_info,
                    "color": 0x1DA1F2,
                    "fields": [
                        {
                            "name": "ğŸ‘¤ ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ",
                            "value": f"[@{username}](https://twitter.com/{username})",
                            "inline": True
                        },
                        {
                            "name": "ğŸ• æŠ•ç¨¿æ™‚åˆ»",
                            "value": jst_time.strftime("%m/%d %H:%M JST"),
                            "inline": True
                        },
                        {
                            "name": "ğŸ”— ãƒ„ã‚¤ãƒ¼ãƒˆãƒªãƒ³ã‚¯",
                            "value": f"[ãƒ„ã‚¤ãƒ¼ãƒˆã‚’è¦‹ã‚‹]({tweet_url})",
                            "inline": False
                        }
                    ],
                    "footer": {
                        "text": "Twitterç›£è¦–Bot v2.1",
                        "icon_url": "https://abs.twimg.com/icons/apple-touch-icon-192x192.png"
                    },
                    "timestamp": created_at
                }
                
                payload = {
                    "embeds": [embed],
                    "username": "Twitterç›£è¦–Bot",
                    "avatar_url": "https://abs.twimg.com/icons/apple-touch-icon-192x192.png"
                }
                
                # ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ä»˜ãã§é€ä¿¡
                max_retries = 3
                for attempt in range(max_retries):
                    try:
                        response = requests.post(webhook_url, json=payload, timeout=30)
                        if response.status_code in [200, 204]:
                            print(f"âœ… Discordé€šçŸ¥é€ä¿¡æˆåŠŸ (è©¦è¡Œå›æ•°: {attempt + 1})")
                            return True
                        elif response.status_code == 429:
                            print(f"âš ï¸ Discord APIåˆ¶é™ - å†è©¦è¡Œ {attempt + 1}/{max_retries}")
                            if attempt < max_retries - 1:
                                import time
                                time.sleep(2 ** attempt)  # æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
                                continue
                        else:
                            print(f"âŒ Discordé€šçŸ¥ã‚¨ãƒ©ãƒ¼: {response.status_code}")
                            print(f"ãƒ¬ã‚¹ãƒãƒ³ã‚¹: {response.text}")
                            
                    except requests.exceptions.Timeout:
                        print(f"â±ï¸ Discordé€šçŸ¥ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ - è©¦è¡Œ {attempt + 1}/{max_retries}")
                        if attempt < max_retries - 1:
                            continue
                    except requests.exceptions.RequestException as e:
                        print(f"âŒ Discordé€šçŸ¥é€ä¿¡ã‚¨ãƒ©ãƒ¼ (è©¦è¡Œ {attempt + 1}): {e}")
                        if attempt < max_retries - 1:
                            continue
                
                return False
                
            except Exception as e:
                print(f"âŒ é€šçŸ¥å‡¦ç†ä¸­ã®ã‚¨ãƒ©ãƒ¼: {e}")
                return False
        
        if __name__ == "__main__":
            main()
        EOF
