name: Twitter Discord Bot (ãƒ‡ãƒãƒƒã‚°å¼·åŒ–ç‰ˆ)

on:
  schedule:
    # 5åˆ†ã”ã¨ã«å®Ÿè¡Œ
    - cron: '*/5 * * * *'
  workflow_dispatch:
    inputs:
      force_check:
        description: 'å¼·åˆ¶å®Ÿè¡Œï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰'
        required: false
        default: 'false'
      debug_level:
        description: 'ãƒ‡ãƒãƒƒã‚°ãƒ¬ãƒ™ãƒ« (1-3)'
        required: false
        default: '2'

jobs:
  monitor-twitter:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    # çŠ¶æ…‹ç®¡ç†ç”¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    - name: Cache bot state
      uses: actions/cache@v3
      with:
        path: |
          bot_state.json
          processed_tweets.json
        key: twitter-bot-state-${{ github.run_number }}
        restore-keys: |
          twitter-bot-state-
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install requests pytz
    
    # ç’°å¢ƒå¤‰æ•°ã®æ¤œè¨¼
    - name: Validate environment variables
      run: |
        echo "ğŸ” ç’°å¢ƒå¤‰æ•°ãƒã‚§ãƒƒã‚¯é–‹å§‹..."
        if [ -z "$BEARER_TOKEN" ]; then echo "âŒ BEARER_TOKEN ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“"; exit 1; fi
        if [ -z "$DISCORD_WEBHOOK" ]; then echo "âŒ DISCORD_WEBHOOK ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“"; exit 1; fi
        if [ -z "$TARGET_USER" ]; then echo "âŒ TARGET_USER ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“"; exit 1; fi
        if [ -z "$KEYWORDS" ]; then echo "âŒ KEYWORDS ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“"; exit 1; fi
        echo "âœ… åŸºæœ¬ç’°å¢ƒå¤‰æ•°OK"
        echo "ğŸ“Š TARGET_USER: $TARGET_USER"
        echo "ğŸ“Š KEYWORDS: $KEYWORDS"
        echo "ğŸ“Š WEBHOOK URL é•·ã•: ${#DISCORD_WEBHOOK}"
      env:
        BEARER_TOKEN: ${{ secrets.BEARER_TOKEN }}
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        TARGET_USER: ${{ secrets.TARGET_USER }}
        KEYWORDS: ${{ secrets.KEYWORDS }}
    
    # Discord Webhook ãƒ†ã‚¹ãƒˆ
    - name: Test Discord webhook
      run: |
        python << 'EOF'
        import requests
        import os
        import json
        from datetime import datetime
        
        webhook_url = os.environ.get('DISCORD_WEBHOOK')
        
        test_payload = {
            "content": "ğŸ§ª **Webhookæ¥ç¶šãƒ†ã‚¹ãƒˆ**",
            "embeds": [{
                "title": "âœ… GitHub Actions â†’ Discord æ¥ç¶šç¢ºèª",
                "description": f"å®Ÿè¡Œæ™‚åˆ»: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}",
                "color": 0x00ff00,
                "footer": {"text": "Twitter Bot æ¥ç¶šãƒ†ã‚¹ãƒˆ"}
            }]
        }
        
        try:
            print("ğŸ”„ Discord Webhook ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...")
            response = requests.post(webhook_url, json=test_payload, timeout=30)
            print(f"ğŸ“¡ ãƒ¬ã‚¹ãƒãƒ³ã‚¹: {response.status_code}")
            print(f"ğŸ“¡ ãƒ˜ãƒƒãƒ€ãƒ¼: {dict(response.headers)}")
            
            if response.status_code in [200, 204]:
                print("âœ… Webhook ãƒ†ã‚¹ãƒˆæˆåŠŸï¼")
            else:
                print(f"âŒ Webhook ã‚¨ãƒ©ãƒ¼: {response.status_code}")
                print(f"ğŸ“ ãƒ¬ã‚¹ãƒãƒ³ã‚¹å†…å®¹: {response.text}")
        except Exception as e:
            print(f"âŒ Webhook ãƒ†ã‚¹ãƒˆå¤±æ•—: {e}")
        EOF
      env:
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
    
    - name: Run Twitter monitor
      env:
        BEARER_TOKEN: ${{ secrets.BEARER_TOKEN }}
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        TARGET_USER: ${{ secrets.TARGET_USER }}
        KEYWORDS: ${{ secrets.KEYWORDS }}
        DEBUG_MODE: 'true'
        DEBUG_LEVEL: ${{ github.event.inputs.debug_level || '2' }}
        MAX_TWEETS_PER_RUN: ${{ secrets.MAX_TWEETS_PER_RUN || '10' }}
        NOTIFICATION_COOLDOWN: ${{ secrets.NOTIFICATION_COOLDOWN || '300' }}
      run: |
        python << 'EOF'
        import requests
        import os
        import json
        from datetime import datetime, timedelta, timezone
        import re
        import time
        import traceback
        import pytz
        
        class TwitterMonitorBot:
            def __init__(self):
                # è¨­å®šèª­ã¿è¾¼ã¿
                self.bearer_token = os.environ.get('BEARER_TOKEN')
                self.webhook_url = os.environ.get('DISCORD_WEBHOOK')
                self.target_user = os.environ.get('TARGET_USER')
                self.keywords = [k.strip() for k in os.environ.get('KEYWORDS', '').split(',') if k.strip()]
                self.debug_mode = os.environ.get('DEBUG_MODE', 'false').lower() == 'true'
                self.debug_level = int(os.environ.get('DEBUG_LEVEL', '2'))
                self.max_tweets_per_run = int(os.environ.get('MAX_TWEETS_PER_RUN', '10'))
                self.notification_cooldown = int(os.environ.get('NOTIFICATION_COOLDOWN', '300'))
                
                # çµ±è¨ˆæƒ…å ±
                self.stats = {
                    'tweets_checked': 0,
                    'notifications_sent': 0,
                    'api_calls': 0,
                    'errors': 0,
                    'start_time': datetime.utcnow()
                }
                
                # Twitter API headers
                self.headers = {
                    'Authorization': f'Bearer {self.bearer_token}',
                    'User-Agent': 'TwitterBot/3.1'
                }
                
                # æ—¥æœ¬æ™‚é–“è¨­å®š
                self.jst = pytz.timezone('Asia/Tokyo')
                
                self.log(f"ğŸ¤– Twitter Monitor Bot v3.1 èµ·å‹• (ãƒ‡ãƒãƒƒã‚°ãƒ¬ãƒ™ãƒ«: {self.debug_level})")
                self.log(f"ğŸ¯ ç›£è¦–å¯¾è±¡: @{self.target_user}")
                self.log(f"ğŸ”‘ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: {', '.join(self.keywords)}")
                self.log(f"ğŸ”— Webhook URL: {'è¨­å®šæ¸ˆã¿' if self.webhook_url else 'æœªè¨­å®š'}")
                
                # è¨­å®šæ¤œè¨¼
                self.validate_config()
        
            def validate_config(self):
                """è¨­å®šã®æ¤œè¨¼"""
                issues = []
                if not self.bearer_token:
                    issues.append("BEARER_TOKENæœªè¨­å®š")
                if not self.webhook_url:
                    issues.append("DISCORD_WEBHOOKæœªè¨­å®š")
                elif not self.webhook_url.startswith('https://discord.com/api/webhooks/'):
                    issues.append("DISCORD_WEBHOOKå½¢å¼ãŒä¸æ­£")
                if not self.target_user:
                    issues.append("TARGET_USERæœªè¨­å®š")
                if not self.keywords:
                    issues.append("KEYWORDSæœªè¨­å®š")
                
                if issues:
                    self.log(f"âŒ è¨­å®šå•é¡Œ: {', '.join(issues)}", "ERROR")
                    raise ValueError(f"è¨­å®šå•é¡Œ: {', '.join(issues)}")
                else:
                    self.log("âœ… è¨­å®šæ¤œè¨¼å®Œäº†")
        
            def log(self, message, level="INFO"):
                """æ”¹å–„ã•ã‚ŒãŸãƒ­ã‚°å‡ºåŠ›"""
                timestamp = datetime.now(self.jst).strftime('%Y-%m-%d %H:%M:%S JST')
                print(f"[{timestamp}] [{level}] {message}")
                
                # ãƒ‡ãƒãƒƒã‚°ãƒ¬ãƒ™ãƒ«3ã®å ´åˆã¯è©³ç´°ãƒ­ã‚°ã‚‚Discordã«é€ä¿¡
                if self.debug_level >= 3 and level in ["ERROR", "WARNING"] and hasattr(self, 'webhook_url'):
                    self.send_debug_log(message, level)
        
            def send_debug_log(self, message, level):
                """ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã‚’Discordã«é€ä¿¡"""
                try:
                    color_map = {"ERROR": 0xff0000, "WARNING": 0xff9900, "INFO": 0x0099ff}
                    
                    embed = {
                        "title": f"ğŸ› ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚° [{level}]",
                        "description": f"```{message[:1500]}```",
                        "color": color_map.get(level, 0x808080),
                        "timestamp": datetime.utcnow().isoformat()
                    }
                    
                    payload = {"embeds": [embed]}
                    requests.post(self.webhook_url, json=payload, timeout=10)
                except:
                    pass  # ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã®é€ä¿¡ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
        
            def load_state(self):
                """çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿"""
                try:
                    with open('bot_state.json', 'r', encoding='utf-8') as f:
                        state = json.load(f)
                        self.log(f"ğŸ“‚ çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿æˆåŠŸ: last_tweet_id={state.get('last_tweet_id', 'None')}")
                        return state
                except FileNotFoundError:
                    self.log("ğŸ“‚ çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ–°è¦ä½œæˆã—ã¾ã™ã€‚")
                    return {
                        'last_tweet_id': None,
                        'last_run_time': None,
                        'total_notifications': 0,
                        'total_tweets_processed': 0
                    }
                except Exception as e:
                    self.log(f"âŒ çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}", "ERROR")
                    return {}
        
            def save_state(self, state):
                """çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜"""
                try:
                    state['last_run_time'] = datetime.utcnow().isoformat()
                    with open('bot_state.json', 'w', encoding='utf-8') as f:
                        json.dump(state, f, ensure_ascii=False, indent=2)
                    self.log("ğŸ’¾ çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜å®Œäº†")
                except Exception as e:
                    self.log(f"âŒ çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}", "ERROR")
        
            def make_api_request(self, url, params=None, max_retries=3):
                """API ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼ˆãƒ‡ãƒãƒƒã‚°å¼·åŒ–ç‰ˆï¼‰"""
                self.stats['api_calls'] += 1
                
                if self.debug_level >= 2:
                    self.log(f"ğŸŒ API Request: {url}")
                    if params:
                        self.log(f"ğŸ“ Parameters: {params}")
                
                for attempt in range(max_retries):
                    try:
                        response = requests.get(url, headers=self.headers, params=params, timeout=30)
                        
                        if self.debug_level >= 3:
                            self.log(f"ğŸ“¡ Response: {response.status_code} - {len(response.text)}æ–‡å­—")
                        
                        if response.status_code == 200:
                            return response
                        elif response.status_code == 429:
                            reset_time = response.headers.get('x-rate-limit-reset')
                            self.log(f"âš ï¸ APIåˆ¶é™ (ãƒªã‚»ãƒƒãƒˆæ™‚åˆ»: {reset_time})", "WARNING")
                            if attempt < max_retries - 1:
                                wait_time = min((2 ** attempt) * 60, 900)  # æœ€å¤§15åˆ†
                                self.log(f"â³ {wait_time}ç§’å¾…æ©Ÿä¸­...")
                                time.sleep(wait_time)
                                continue
                        elif response.status_code == 401:
                            self.log("âŒ èªè¨¼ã‚¨ãƒ©ãƒ¼: Bearer Tokenã‚’ç¢ºèªã—ã¦ãã ã•ã„", "ERROR")
                            return None
                        else:
                            self.log(f"âŒ API ã‚¨ãƒ©ãƒ¼: {response.status_code} - {response.text[:200]}", "ERROR")
                            if attempt < max_retries - 1:
                                time.sleep(5)
                                continue
                            
                    except Exception as e:
                        self.log(f"ğŸ“¡ ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼ (è©¦è¡Œ {attempt + 1}): {e}", "WARNING")
                        if attempt < max_retries - 1:
                            time.sleep(5)
                            continue
                
                self.stats['errors'] += 1
                return None
        
            def get_user_id(self):
                """ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’å–å¾—"""
                user_url = f'https://api.twitter.com/2/users/by/username/{self.target_user}'
                response = self.make_api_request(user_url)
                
                if not response:
                    return None
                
                try:
                    user_data = response.json()
                    if 'data' not in user_data:
                        self.log(f"âŒ ãƒ¦ãƒ¼ã‚¶ãƒ¼ '{self.target_user}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", "ERROR")
                        if 'errors' in user_data:
                            self.log(f"ğŸ“ APIã‚¨ãƒ©ãƒ¼è©³ç´°: {user_data['errors']}", "ERROR")
                        return None
                    
                    user_id = user_data['data']['id']
                    self.log(f"âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼IDå–å¾—: {user_id}")
                    return user_id
                    
                except Exception as e:
                    self.log(f"âŒ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿è§£æã‚¨ãƒ©ãƒ¼: {e}", "ERROR")
                    return None
        
            def get_recent_tweets(self, user_id, since_id=None):
                """æœ€æ–°ãƒ„ã‚¤ãƒ¼ãƒˆã‚’å–å¾—"""
                tweets_url = f'https://api.twitter.com/2/users/{user_id}/tweets'
                
                params = {
                    'max_results': min(self.max_tweets_per_run, 100),
                    'tweet.fields': 'created_at,public_metrics,context_annotations,lang',
                    'exclude': 'retweets,replies'
                }
                
                if since_id:
                    params['since_id'] = since_id
                    self.log(f"ğŸ“Š since_idæŒ‡å®š: {since_id}")
                else:
                    # éå»15åˆ†ã®ãƒ„ã‚¤ãƒ¼ãƒˆã‚’å–å¾—
                    end_time = datetime.utcnow()
                    start_time = end_time - timedelta(minutes=15)
                    params['start_time'] = start_time.strftime('%Y-%m-%dT%H:%M:%SZ')
                    params['end_time'] = end_time.strftime('%Y-%m-%dT%H:%M:%SZ')
                    self.log(f"ğŸ• æ™‚é–“ç¯„å›²: {start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')} UTC")
                
                response = self.make_api_request(tweets_url, params)
                
                if not response:
                    return None
                
                try:
                    tweets_data = response.json()
                    
                    if self.debug_level >= 2:
                        self.log(f"ğŸ“Š APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ keys: {list(tweets_data.keys())}")
                    
                    if 'data' not in tweets_data:
                        if 'errors' in tweets_data:
                            self.log(f"âŒ Twitter API ã‚¨ãƒ©ãƒ¼: {tweets_data['errors']}", "ERROR")
                        else:
                            self.log("â„¹ï¸ æ–°ã—ã„ãƒ„ã‚¤ãƒ¼ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“")
                        return []
                    
                    tweets = tweets_data['data']
                    self.log(f"ğŸ“ {len(tweets)}ä»¶ã®ãƒ„ã‚¤ãƒ¼ãƒˆã‚’å–å¾—")
                    self.stats['tweets_checked'] += len(tweets)
                    
                    if self.debug_level >= 2:
                        for i, tweet in enumerate(tweets[:3]):  # æœ€åˆã®3ä»¶ã‚’ã‚µãƒ³ãƒ—ãƒ«è¡¨ç¤º
                            self.log(f"ğŸ“„ Tweet {i+1}: {tweet['text'][:50]}...")
                    
                    return tweets
                    
                except Exception as e:
                    self.log(f"âŒ ãƒ„ã‚¤ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿è§£æã‚¨ãƒ©ãƒ¼: {e}", "ERROR")
                    return None
        
            def check_keywords(self, text, keywords):
                """ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯"""
                matched_keywords = []
                text_lower = text.lower()
                
                for keyword in keywords:
                    if keyword.lower() in text_lower:
                        matched_keywords.append(keyword)
                        if self.debug_level >= 2:
                            self.log(f"ğŸ¯ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒ: '{keyword}' in '{text[:30]}...'")
                
                return matched_keywords
        
            def test_discord_webhook(self):
                """Discord Webhook ã®ãƒ†ã‚¹ãƒˆ"""
                test_payload = {
                    "content": "ğŸ§ª **Botå‹•ä½œãƒ†ã‚¹ãƒˆ**",
                    "embeds": [{
                        "title": "âœ… Twitterç›£è¦–Bot ãƒ†ã‚¹ãƒˆé€šçŸ¥",
                        "description": f"å®Ÿè¡Œæ™‚åˆ»: {datetime.now(self.jst).strftime('%Y-%m-%d %H:%M:%S JST')}",
                        "color": 0x00ff00,
                        "fields": [
                            {"name": "ç›£è¦–å¯¾è±¡", "value": f"@{self.target_user}", "inline": True},
                            {"name": "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰", "value": ", ".join(self.keywords), "inline": True}
                        ]
                    }]
                }
                
                try:
                    response = requests.post(self.webhook_url, json=test_payload, timeout=30)
                    if response.status_code in [200, 204]:
                        self.log("âœ… Discord Webhook ãƒ†ã‚¹ãƒˆæˆåŠŸ")
                        return True
                    else:
                        self.log(f"âŒ Discord Webhook ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {response.status_code}", "ERROR")
                        return False
                except Exception as e:
                    self.log(f"âŒ Discord Webhook ãƒ†ã‚¹ãƒˆå¤±æ•—: {e}", "ERROR")
                    return False
        
            def send_discord_notification(self, tweet_text, matched_keywords, tweet_data):
                """Discordé€šçŸ¥é€ä¿¡ï¼ˆãƒ‡ãƒãƒƒã‚°å¼·åŒ–ç‰ˆï¼‰"""
                try:
                    tweet_id = tweet_data['id']
                    created_at = tweet_data['created_at']
                    
                    # UTC -> JSTå¤‰æ›
                    utc_time = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                    jst_time = utc_time.astimezone(self.jst)
                    
                    # ãƒ†ã‚­ã‚¹ãƒˆé•·åˆ¶é™
                    display_text = tweet_text if len(tweet_text) <= 300 else tweet_text[:300] + "..."
                    
                    embed = {
                        "title": f"ğŸš¨ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œå‡º: {', '.join(matched_keywords)}",
                        "description": display_text,
                        "color": 0x1DA1F2,
                        "fields": [
                            {
                                "name": "ğŸ‘¤ æŠ•ç¨¿è€…",
                                "value": f"[@{self.target_user}](https://twitter.com/{self.target_user})",
                                "inline": True
                            },
                            {
                                "name": "ğŸ• æŠ•ç¨¿æ™‚åˆ»",
                                "value": jst_time.strftime("%m/%d %H:%M JST"),
                                "inline": True
                            },
                            {
                                "name": "ğŸ”— ãƒªãƒ³ã‚¯",
                                "value": f"[ãƒ„ã‚¤ãƒ¼ãƒˆã‚’è¦‹ã‚‹](https://twitter.com/{self.target_user}/status/{tweet_id})",
                                "inline": False
                            }
                        ],
                        "footer": {
                            "text": f"Twitterç›£è¦–Bot v3.1 | Debug Level: {self.debug_level}",
                        },
                        "timestamp": created_at
                    }
                    
                    payload = {
                        "embeds": [embed],
                        "username": "Twitterç›£è¦–Bot",
                        "avatar_url": "https://abs.twimg.com/icons/apple-touch-icon-192x192.png"
                    }
                    
                    if self.debug_level >= 2:
                        self.log(f"ğŸ“¤ Discordé€šçŸ¥é€ä¿¡æº–å‚™: {len(json.dumps(payload))}æ–‡å­—")
                    
                    # Discord API ã«ãƒªãƒˆãƒ©ã‚¤ä»˜ãã§é€ä¿¡
                    for attempt in range(3):
                        try:
                            response = requests.post(self.webhook_url, json=payload, timeout=30)
                            
                            if self.debug_level >= 2:
                                self.log(f"ğŸ“¡ Discord Response: {response.status_code}")
                            
                            if response.status_code in [200, 204]:
                                self.log(f"âœ… Discordé€šçŸ¥é€ä¿¡æˆåŠŸ (è©¦è¡Œ: {attempt + 1})")
                                self.stats['notifications_sent'] += 1
                                return True
                            elif response.status_code == 429:
                                wait_time = 5 * (attempt + 1)
                                self.log(f"âš ï¸ Discord APIåˆ¶é™ - {wait_time}ç§’å¾…æ©Ÿ", "WARNING")
                                time.sleep(wait_time)
                                continue
                            else:
                                self.log(f"âŒ Discordé€šçŸ¥ã‚¨ãƒ©ãƒ¼: {response.status_code} - {response.text[:200]}", "ERROR")
                                
                        except Exception as e:
                            self.log(f"âŒ Discordé€šçŸ¥é€ä¿¡ã‚¨ãƒ©ãƒ¼ (è©¦è¡Œ {attempt + 1}): {e}", "ERROR")
                            if attempt < 2:
                                time.sleep(5)
                                continue
                    
                    self.stats['errors'] += 1
                    return False
                    
                except Exception as e:
                    self.log(f"âŒ é€šçŸ¥å‡¦ç†ä¸­ã®äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}", "ERROR")
                    if self.debug_level >= 3:
                        traceback.print_exc()
                    return False
        
            def send_summary_notification(self):
                """å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼ã‚’Discordã«é€ä¿¡"""
                runtime = datetime.utcnow() - self.stats['start_time']
                
                status_color = 0x00ff00 if self.stats['errors'] == 0 else (0xff9900 if self.stats['errors'] < 3 else 0xff0000)
                status_text = "æ­£å¸¸" if self.stats['errors'] == 0 else f"è­¦å‘Š({self.stats['errors']}ã‚¨ãƒ©ãƒ¼)"
                
                embed = {
                    "title": f"ğŸ“Š å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼ - {status_text}",
                    "color": status_color,
                    "fields": [
                        {"name": "ğŸ” ãƒã‚§ãƒƒã‚¯ã—ãŸãƒ„ã‚¤ãƒ¼ãƒˆæ•°", "value": str(self.stats['tweets_checked']), "inline": True},
                        {"name": "ğŸ”” é€ä¿¡ã—ãŸé€šçŸ¥æ•°", "value": str(self.stats['notifications_sent']), "inline": True},
                        {"name": "ğŸŒ APIå‘¼ã³å‡ºã—å›æ•°", "value": str(self.stats['api_calls']), "inline": True},
                        {"name": "âŒ ã‚¨ãƒ©ãƒ¼å›æ•°", "value": str(self.stats['errors']), "inline": True},
                        {"name": "â±ï¸ å®Ÿè¡Œæ™‚é–“", "value": f"{runtime.total_seconds():.1f}ç§’", "inline": True},
                        {"name": "ğŸ• å®Ÿè¡Œæ™‚åˆ»", "value": datetime.now(self.jst).strftime("%m/%d %H:%M JST"), "inline": True}
                    ],
                    "footer": {"text": f"ãƒ‡ãƒãƒƒã‚°ãƒ¬ãƒ™ãƒ« {self.debug_level} | v3.1"},
                    "timestamp": datetime.utcnow().isoformat()
                }
                
                payload = {"embeds": [embed]}
                
                try:
                    response = requests.post(self.webhook_url, json=payload, timeout=10)
                    if response.status_code not in [200, 204]:
                        self.log(f"âš ï¸ ã‚µãƒãƒªãƒ¼é€ä¿¡ã‚¨ãƒ©ãƒ¼: {response.status_code}", "WARNING")
                except Exception as e:
                    self.log(f"âš ï¸ ã‚µãƒãƒªãƒ¼é€ä¿¡å¤±æ•—: {e}", "WARNING")
        
            def run(self):
                """ãƒ¡ã‚¤ãƒ³å‡¦ç†"""
                try:
                    self.log("ğŸš€ ãƒ¡ã‚¤ãƒ³å‡¦ç†é–‹å§‹")
                    
                    # Discord Webhook ãƒ†ã‚¹ãƒˆï¼ˆãƒ‡ãƒãƒƒã‚°ãƒ¬ãƒ™ãƒ«2ä»¥ä¸Šã®å ´åˆï¼‰
                    if self.debug_level >= 2:
                        if not self.test_discord_webhook():
                            self.log("âŒ Discord Webhook ãƒ†ã‚¹ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ", "ERROR")
                            return
                    
                    # çŠ¶æ…‹èª­ã¿è¾¼ã¿
                    state = self.load_state()
                    
                    # ãƒ¦ãƒ¼ã‚¶ãƒ¼IDå–å¾—
                    user_id = self.get_user_id()
                    if not user_id:
                        self.log("âŒ ãƒ¦ãƒ¼ã‚¶ãƒ¼IDå–å¾—å¤±æ•—", "ERROR")
                        return
                    
                    # ãƒ„ã‚¤ãƒ¼ãƒˆå–å¾—
                    tweets = self.get_recent_tweets(user_id, state.get('last_tweet_id'))
                    if tweets is None:
                        self.log("âŒ ãƒ„ã‚¤ãƒ¼ãƒˆå–å¾—å¤±æ•—", "ERROR")
                        return
                    
                    if not tweets:
                        self.log("âœ… æ–°ã—ã„ãƒ„ã‚¤ãƒ¼ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
                        if self.debug_level >= 1:
                            self.send_summary_notification()
                        return
                    
                    # ãƒ„ã‚¤ãƒ¼ãƒˆå‡¦ç†
                    tweets.sort(key=lambda x: x['created_at'])  # å¤ã„é †
                    notifications_sent = 0
                    new_last_tweet_id = state.get('last_tweet_id')
                    
                    for tweet in tweets:
                        tweet_id = tweet['id']
                        tweet_text = tweet['text']
                        
                        if self.debug_level >= 2:
                            self.log(f"ğŸ” ãƒ„ã‚¤ãƒ¼ãƒˆåˆ†æ: {tweet_id}")
                        
                        # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
                        matched_keywords = self.check_keywords(tweet_text, self.keywords)
                        
                        if matched_keywords:
                            self.log(f"ğŸ¯ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œå‡º: {matched_keywords}")
                            self.log(f"ğŸ“ ãƒ„ã‚¤ãƒ¼ãƒˆå†…å®¹: {tweet_text[:100]}...")
                            
                            # é€šçŸ¥é€ä¿¡
                            success = self.send_discord_notification(tweet_text, matched_keywords, tweet)
                            
                            if success:
                                notifications_sent += 1
                                self.log(f"ğŸ‰ é€šçŸ¥é€ä¿¡æˆåŠŸ: {matched_keywords}")
                            else:
                                self.log(f"âŒ é€šçŸ¥é€ä¿¡å¤±æ•—: {tweet_id}", "ERROR")
                        
                        new_last_tweet_id = tweet_id
                    
                    # çŠ¶æ…‹ä¿å­˜
                    state['last_tweet_id'] = new_last_tweet_id
                    state['total_notifications'] = state.get('total_notifications', 0) + notifications_sent
                    state['total_tweets_processed'] = state.get('total_tweets_processed', 0) + len(tweets)
                    self.save_state(state)
                    
                    # çµæœå‡ºåŠ›
                    self.log(f"ğŸ¯ å‡¦ç†å®Œäº†: {len(tweets)}ä»¶ã®ãƒ„ã‚¤ãƒ¼ãƒˆã‚’ç¢ºèª, {notifications_sent}ä»¶ã®é€šçŸ¥ã‚’é€ä¿¡")
                    
                    # ã‚µãƒãƒªãƒ¼é€ä¿¡
                    if self.debug_level >= 1 or notifications_sent > 0:
                        self.send_summary_notification()
                    
                except Exception as e:
                    self.log(f"âŒ äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}", "ERROR")
                    if self.debug_level >= 2:
                        traceback.print_exc()
                    
                    # ã‚¨ãƒ©ãƒ¼é€šçŸ¥
                    try:
                        error_embed = {
                            "title": "ğŸš¨ Twitter Bot é‡å¤§ã‚¨ãƒ©ãƒ¼",
                            "description": f"```{str(e)[:1500]}```",
                            "color": 0xff0000,
                            "timestamp": datetime.utcnow().isoformat()
                        }
                        requests.post(self.webhook_url, json={"embeds": [error_embed]}, timeout=10)
                    except:
                        pass
        
        # ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ
        if __name__ == "__main__":
            bot = TwitterMonitorBot()
            bot.run()
        EOF
        # ç¾åœ¨ã®YAMLãƒ•ã‚¡ã‚¤ãƒ«ã«ä»¥ä¸‹ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ï¼š

# æ—¢å­˜ã® "Install dependencies" ã‚¹ãƒ†ãƒƒãƒ—ã®å¾Œã«è¿½åŠ ï¼š
    - name: Test Discord webhook connection
      run: |
        python << 'EOF'
        import requests
        import os
        from datetime import datetime
        
        webhook_url = os.environ.get('DISCORD_WEBHOOK')
        
        # åŸºæœ¬çš„ãªæ¥ç¶šãƒ†ã‚¹ãƒˆ
        test_payload = {
            "content": "ğŸ§ª **æ¥ç¶šãƒ†ã‚¹ãƒˆ**",
            "embeds": [{
                "title": "âœ… GitHub Actions â†’ Discord æ¥ç¶šç¢ºèª",
                "description": f"å®Ÿè¡Œæ™‚åˆ»: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}",
                "color": 0x00ff00
            }]
        }
        
        try:
            print("ğŸ”„ Discord Webhook ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...")
            response = requests.post(webhook_url, json=test_payload, timeout=30)
            print(f"ğŸ“¡ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {response.status_code}")
            print(f"ğŸ“¡ ãƒ¬ã‚¹ãƒãƒ³ã‚¹: {response.text}")
            
            if response.status_code in [200, 204]:
                print("âœ… Webhook æ¥ç¶šæˆåŠŸï¼")
            else:
                print(f"âŒ Webhook æ¥ç¶šå¤±æ•—: {response.status_code}")
                print("ğŸ” Discord Webhook URLã‚’ç¢ºèªã—ã¦ãã ã•ã„")
        except Exception as e:
            print(f"âŒ æ¥ç¶šã‚¨ãƒ©ãƒ¼: {e}")
            print("ğŸ” ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã¾ãŸã¯URLè¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„")
        EOF
      env:
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}

# æ—¢å­˜ã® "Run Twitter monitor" ã‚¹ãƒ†ãƒƒãƒ—ã® env ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«è¿½åŠ ï¼š
        DEBUG_MODE: 'true'  # ã“ã®è¡Œã‚’è¿½åŠ 
        
# ãã—ã¦ã€Pythonã‚³ãƒ¼ãƒ‰ã® send_discord_notification é–¢æ•°ã‚’ä»¥ä¸‹ã«ç½®ãæ›ãˆï¼š
